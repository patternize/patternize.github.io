(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{131:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return b}));var r=n(0),a=n.n(r);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=a.a.createContext({}),s=function(e){var t=a.a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=s(e.components);return a.a.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},f=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),d=s(n),f=r,b=d["".concat(o,".").concat(f)]||d[f]||p[f]||l;return n?a.a.createElement(b,i(i({ref:t},u),{},{components:n})):a.a.createElement(b,i({ref:t},u))}));function b(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=f;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var u=2;u<l;u++)o[u]=n[u];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},132:function(e,t,n){"use strict";function r(e){var t,n,a="";if("string"==typeof e||"number"==typeof e)a+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=r(e[t]))&&(a&&(a+=" "),a+=n);else for(t in e)e[t]&&(a&&(a+=" "),a+=t);return a}t.a=function(){for(var e,t,n=0,a="";n<arguments.length;)(e=arguments[n++])&&(t=r(e))&&(a&&(a+=" "),a+=t);return a}},133:function(e,t,n){"use strict";var r=n(0),a=n.n(r),l=n(136),o=n(132),i=n(48),c=n.n(i);const u=37,s=39;t.a=function(e){const{block:t,children:n,defaultValue:i,values:d,groupId:p}=e,{tabGroupChoices:f,setTabGroupChoices:b}=Object(l.a)(),[v,g]=Object(r.useState)(i),[h,m]=Object(r.useState)(!1);if(null!=p){const e=f[p];null!=e&&e!==v&&d.some(t=>t.value===e)&&g(e)}const O=e=>{g(e),null!=p&&b(p,e)},y=[],j=e=>{e.metaKey||e.altKey||e.ctrlKey||m(!0)},T=()=>{m(!1)};return Object(r.useEffect)(()=>{window.addEventListener("keydown",j),window.addEventListener("mousedown",T)},[]),a.a.createElement("div",null,a.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(o.a)("tabs",{"tabs--block":t})},d.map(({value:e,label:t})=>a.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":v===e,className:Object(o.a)("tabs__item",c.a.tabItem,{"tabs__item--active":v===e}),style:h?{}:{outline:"none"},key:e,ref:e=>y.push(e),onKeyDown:e=>{((e,t,n)=>{switch(n.keyCode){case s:((e,t)=>{const n=e.indexOf(t)+1;e[n]?e[n].focus():e[0].focus()})(e,t);break;case u:((e,t)=>{const n=e.indexOf(t)-1;e[n]?e[n].focus():e[e.length-1].focus()})(e,t)}})(y,e.target,e),j(e)},onFocus:()=>O(e),onClick:()=>{O(e),m(!1)},onPointerDown:()=>m(!1)},t))),a.a.createElement("div",{role:"tabpanel",className:"margin-vert--md"},r.Children.toArray(n).filter(e=>e.props.value===v)[0]))}},134:function(e,t,n){"use strict";var r=n(0),a=n.n(r);t.a=function(e){return a.a.createElement("div",null,e.children)}},135:function(e,t,n){"use strict";var r=n(0);const a=Object(r.createContext)(void 0);t.a=a},136:function(e,t,n){"use strict";var r=n(0),a=n(135);t.a=function(){const e=Object(r.useContext)(a.a);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},71:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return u})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return p}));var r=n(1),a=n(6),l=(n(0),n(131)),o=n(133),i=n(134),c={id:"LC103",title:"LC103. Binary Tree Zigzag Level Order Traversal",sidebar_label:"LC103. Binary Tree Zigzag Level Order Traversal",tags:["Patterns/Tree","DataStructures/Tree"]},u={unversionedId:"QuestionBank/Leetcode/LC103",id:"QuestionBank/Leetcode/LC103",isDocsHomePage:!1,title:"LC103. Binary Tree Zigzag Level Order Traversal",description:"Problem Description",source:"@site/docs/QuestionBank/Leetcode/103. Binary Tree Zigzag Level Order Traversal.md",permalink:"/docs/QuestionBank/Leetcode/LC103",sidebar_label:"LC103. Binary Tree Zigzag Level Order Traversal",sidebar:"Data Structure",previous:{title:"LC98. Validate Binary Search Tree",permalink:"/docs/QuestionBank/Leetcode/LC98"},next:{title:"VList",permalink:"/docs/DataStructures/Advanced/VList"}},s=[{value:"Problem Description",id:"problem-description",children:[]},{value:"Solution",id:"solution",children:[{value:"High level strategy",id:"high-level-strategy",children:[]},{value:"Code",id:"code",children:[]}]},{value:"Other Solutions",id:"other-solutions",children:[]}],d={rightToc:s};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(l.b)("wrapper",Object(r.a)({},d,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)("h2",{id:"problem-description"},"Problem Description"),Object(l.b)("p",null,"Source: ",Object(l.b)("a",Object(r.a)({parentName:"p"},{href:"https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/"}),"https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/")),Object(l.b)("p",null,"Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between)."),Object(l.b)("p",null,"For example:\nGiven binary tree ","[3, 9, 20, null, null, 15, 7]",","),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{}),"    3\n   / \\\n  9  20\n    /  \\\n   15   7\n")),Object(l.b)("p",null,"return its zigzag level order traversal as: [","[3]",", ","[20, 9]",", ","[15, 7]","]."),Object(l.b)("h2",{id:"solution"},"Solution"),Object(l.b)("h3",{id:"high-level-strategy"},"High level strategy"),Object(l.b)("p",null,"Our strategy to solve this problem will be to conduct a breadth-first search. However, unlike an ordinary breadth-first search, we will only traverse from the left to right on even levels (including zero), and from the right to left on odd levels. The time and space complexity of this solution is ",Object(l.b)("strong",{parentName:"p"},"O(n)"),"."),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{}),"    3   level 0; traverse from left to right [3]\n   / \\\n  9  20   level 1; traverse from right to left [20, 9]\n    /  \\\n   15   7   level 2; traverse from left to right [15, 7]\n")),Object(l.b)("h3",{id:"code"},"Code"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-javascript"}),"const zigzagLevelOrder = (root) => {\n    let result = [];\n    \n    let recurse = (node, level) => {\n        if (node === null) return;\n        if (!result[level]) {\n            result[level] = [];\n        }\n        \n        if (level % 2 === 0) {\n            result[level].push(node.val); // left to right traversal is implemented with the push method\n        } else {\n            result[level].unshift(node.val); // right to left traversal is implemented with the unshift method\n        }\n        \n        recurse(node.left, level + 1);\n        recurse(node.right, level + 1);\n    };\n    \n    \n    recurse(root, 0);\n    return result;\n};\n")),Object(l.b)("h2",{id:"other-solutions"},"Other Solutions"),Object(l.b)(o.a,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Python",value:"py"}],mdxType:"Tabs"},Object(l.b)(i.a,{value:"java",mdxType:"TabItem"},Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),"class Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n            List<List<Integer>> toRet = new ArrayList<>();\n            if (root == null) return toRet;\n            Queue<TreeNode> queue = new LinkedList<>();\n            queue.add(root);\n            int count;\n            boolean leftToRight = true;\n            while(!queue.isEmpty()){\n                count = queue.size();\n                ArrayList<Integer> level = new ArrayList<>();\n                for (int i = 0; i < count; i ++){\n                    TreeNode node = queue.poll();\n                    if(leftToRight) {\n                        level.add(node.val);\n                    } else {\n                        level.add(0, node.val);\n                    }\n                    if(node.left != null){\n                        queue.add(node.left);\n                    }\n                    if(node.right != null){\n                        queue.add(node.right);\n                    }\n                }\n                leftToRight = !leftToRight;\n                toRet.add(level);\n            }\n            return toRet;\n        }\n}\n"))),Object(l.b)(i.a,{value:"py",mdxType:"TabItem"},Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-py"}),'class Solution(object):\n    def zigzagLevelOrder(self, root):\n        """\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        """\n        if not root: \n            return []\n        leftToRight = True \n        dq = collections.deque() \n        dq.append(root)\n        traversal = [] \n        while len(dq) > 0:\n            level = []\n            for i in range(len(dq)):\n                if leftToRight:\n                    cur = dq.popleft()\n                    level.append(cur.val)\n                    if cur.left:\n                        dq.append(cur.left)\n                    if cur.right:\n                        dq.append(cur.right)\n                else:\n                    cur = dq.pop()\n                    level.append(cur.val)\n                    if cur.right:\n                        dq.appendleft(cur.right)\n                    if cur.left:\n                        dq.appendleft(cur.left)\n            traversal.append(level)\n            leftToRight = not leftToRight\n        return traversal\n')))))}p.isMDXComponent=!0}}]);