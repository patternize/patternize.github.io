(window.webpackJsonp=window.webpackJsonp||[]).push([[60,5,37,55,70],{133:function(n,e,t){"use strict";t.r(e),t.d(e,"frontMatter",(function(){return p})),t.d(e,"metadata",(function(){return d})),t.d(e,"toc",(function(){return b})),t.d(e,"default",(function(){return h}));var i=t(147),a=t(149),r=(t(0),t(148)),o=t(151),m=t(152),u=t(54),l=t(59),c=t(57),s=t(60),p={id:"index",title:"Optimal Path Finding Questions",sidebar_label:"Optimal Path Finding"},d={unversionedId:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/index",id:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/index",isDocsHomePage:!1,title:"Optimal Path Finding Questions",description:"<Tabs",source:"@site/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/index.md",slug:"/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/index",permalink:"/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/index",version:"current",sidebar_label:"Optimal Path Finding",sidebar:"Patterns",previous:{title:"Matrix Questions",permalink:"/docs/Patterns/DynamicProgramming/Coordinate/Matrix/index"},next:{title:"Bit Manipulation",permalink:"/docs/Patterns/BitManipulation/Introduction"}},b=[],g={toc:b};function h(n){var e=n.components,t=Object(a.a)(n,["components"]);return Object(r.b)("wrapper",Object(i.a)({},g,t,{components:e,mdxType:"MDXLayout"}),Object(r.b)(o.a,{defaultValue:"Unique Path",values:[{label:"Unique Path",value:"Unique Path"},{label:"Unique Path II",value:"Unique Path II"},{label:"Minimum Path Sum",value:"MinimumPathSum"},{label:"Minimum Falling Path Sum",value:"MinimumFallingPathSum"}],mdxType:"Tabs"},Object(r.b)(m.a,{value:"Unique Path",mdxType:"TabItem"},Object(r.b)(u.default,{mdxType:"UniquePaths"})),Object(r.b)(m.a,{value:"Unique Path II",mdxType:"TabItem"},Object(r.b)(l.default,{mdxType:"UniquePathsII"})),Object(r.b)(m.a,{value:"MinimumPathSum",mdxType:"TabItem"},Object(r.b)(c.default,{mdxType:"MinimumPathSum"})),Object(r.b)(m.a,{value:"MinimumFallingPathSum",mdxType:"TabItem"},Object(r.b)(s.default,{mdxType:"MinimumFallingPathSum"}))))}h.isMDXComponent=!0},147:function(n,e,t){"use strict";function i(){return(i=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(n[i]=t[i])}return n}).apply(this,arguments)}t.d(e,"a",(function(){return i}))},148:function(n,e,t){"use strict";t.d(e,"a",(function(){return s})),t.d(e,"b",(function(){return b}));var i=t(0),a=t.n(i);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,i)}return t}function m(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function u(n,e){if(null==n)return{};var t,i,a=function(n,e){if(null==n)return{};var t,i,a={},r=Object.keys(n);for(i=0;i<r.length;i++)t=r[i],e.indexOf(t)>=0||(a[t]=n[t]);return a}(n,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(i=0;i<r.length;i++)t=r[i],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(a[t]=n[t])}return a}var l=a.a.createContext({}),c=function(n){var e=a.a.useContext(l),t=e;return n&&(t="function"==typeof n?n(e):m(m({},e),n)),t},s=function(n){var e=c(n.components);return a.a.createElement(l.Provider,{value:e},n.children)},p={inlineCode:"code",wrapper:function(n){var e=n.children;return a.a.createElement(a.a.Fragment,{},e)}},d=a.a.forwardRef((function(n,e){var t=n.components,i=n.mdxType,r=n.originalType,o=n.parentName,l=u(n,["components","mdxType","originalType","parentName"]),s=c(t),d=i,b=s["".concat(o,".").concat(d)]||s[d]||p[d]||r;return t?a.a.createElement(b,m(m({ref:e},l),{},{components:t})):a.a.createElement(b,m({ref:e},l))}));function b(n,e){var t=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var r=t.length,o=new Array(r);o[0]=d;var m={};for(var u in e)hasOwnProperty.call(e,u)&&(m[u]=e[u]);m.originalType=n,m.mdxType="string"==typeof n?n:i,o[1]=m;for(var l=2;l<r;l++)o[l]=t[l];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},149:function(n,e,t){"use strict";function i(n,e){if(null==n)return{};var t,i,a={},r=Object.keys(n);for(i=0;i<r.length;i++)t=r[i],e.indexOf(t)>=0||(a[t]=n[t]);return a}t.d(e,"a",(function(){return i}))},150:function(n,e,t){"use strict";function i(n){var e,t,a="";if("string"==typeof n||"number"==typeof n)a+=n;else if("object"==typeof n)if(Array.isArray(n))for(e=0;e<n.length;e++)n[e]&&(t=i(n[e]))&&(a&&(a+=" "),a+=t);else for(e in n)n[e]&&(a&&(a+=" "),a+=e);return a}e.a=function(){for(var n,e,t=0,a="";t<arguments.length;)(n=arguments[t++])&&(e=i(n))&&(a&&(a+=" "),a+=e);return a}},151:function(n,e,t){"use strict";var i=t(0),a=t.n(i),r=t(153),o=t(150),m=t(53),u=t.n(m);const l=37,c=39;e.a=function(n){const{lazy:e,block:t,defaultValue:m,values:s,groupId:p,className:d}=n,{tabGroupChoices:b,setTabGroupChoices:g}=Object(r.a)(),[h,j]=Object(i.useState)(m),f=i.Children.toArray(n.children);if(null!=p){const n=b[p];null!=n&&n!==h&&s.some((e=>e.value===n))&&j(n)}const O=n=>{j(n),null!=p&&g(p,n)},P=[];return a.a.createElement("div",null,a.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(o.a)("tabs",{"tabs--block":t},d)},s.map((({value:n,label:e})=>a.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":h===n,className:Object(o.a)("tabs__item",u.a.tabItem,{"tabs__item--active":h===n}),key:n,ref:n=>P.push(n),onKeyDown:n=>{((n,e,t)=>{switch(t.keyCode){case c:((n,e)=>{const t=n.indexOf(e)+1;n[t]?n[t].focus():n[0].focus()})(n,e);break;case l:((n,e)=>{const t=n.indexOf(e)-1;n[t]?n[t].focus():n[n.length-1].focus()})(n,e)}})(P,n.target,n)},onFocus:()=>O(n),onClick:()=>{O(n)}},e)))),e?Object(i.cloneElement)(f.filter((n=>n.props.value===h))[0],{className:"margin-vert--md"}):a.a.createElement("div",{className:"margin-vert--md"},f.map(((n,e)=>Object(i.cloneElement)(n,{key:e,hidden:n.props.value!==h})))))}},152:function(n,e,t){"use strict";var i=t(147),a=t(0),r=t.n(a);e.a=function({children:n,hidden:e,className:t}){return r.a.createElement("div",Object(i.a)({role:"tabpanel"},{hidden:e,className:t}),n)}},153:function(n,e,t){"use strict";var i=t(0),a=t(154);e.a=function(){const n=Object(i.useContext)(a.a);if(null==n)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return n}},154:function(n,e,t){"use strict";var i=t(0);const a=Object(i.createContext)(void 0);e.a=a},190:function(n,e,t){"use strict";t.r(e),e.default=t.p+"assets/images/UnqiuePaths-e851675d74abe535a9b38e878b0ef1bc.jpg"},194:function(n,e,t){"use strict";t.r(e),e.default=t.p+"assets/images/MinimumPathSum-442c8c2cba704b5eb8e8baf1a7ec4672.jpg"},198:function(n,e,t){"use strict";t.r(e),e.default=t.p+"assets/images/UnqiuePathsII-1a74a9add9be3282543fdcf71d291ca8.jpg"},199:function(n,e,t){"use strict";t.r(e),e.default=t.p+"assets/images/MinimumFallingPathSum-a4ffea2f95fc4bf4f745c33c53b2cb67.jpg"},54:function(n,e,t){"use strict";t.r(e),t.d(e,"frontMatter",(function(){return u})),t.d(e,"metadata",(function(){return l})),t.d(e,"toc",(function(){return c})),t.d(e,"default",(function(){return p}));var i=t(147),a=t(149),r=(t(0),t(148)),o=t(151),m=t(152),u={title:"Leetcode 62. Unique Paths",tags:["DynamicProgramming/Coordinate"]},l={unversionedId:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/62-unique-paths",id:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/62-unique-paths",isDocsHomePage:!1,title:"Leetcode 62. Unique Paths",description:"Question Description",source:"@site/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/62-unique-paths.md",slug:"/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/62-unique-paths",permalink:"/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/62-unique-paths",version:"current"},c=[{value:"Example 1:",id:"example-1",children:[]},{value:"Example 2:",id:"example-2",children:[]}],s={toc:c};function p(n){var e=n.components,u=Object(a.a)(n,["components"]);return Object(r.b)("wrapper",Object(i.a)({},s,u,{components:e,mdxType:"MDXLayout"}),Object(r.b)("p",null,Object(r.b)("img",{src:t(190).default})),Object(r.b)("h1",{id:"question-description"},"Question Description"),Object(r.b)("p",null,"Original Question: ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://leetcode.com/problems/unique-paths/"}),"Leetcode 62. Unique Paths")),Object(r.b)("p",null,"A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below)."),Object(r.b)("p",null,"The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below)."),Object(r.b)("p",null,"How many possible unique paths are there?"),Object(r.b)("h3",{id:"example-1"},"Example 1:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{}),"Input: m = 3, n = 2\nOutput: 3\nExplanation:\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Right -> Down\n2. Right -> Down -> Right\n3. Down -> Right -> Right\n")),Object(r.b)("h3",{id:"example-2"},"Example 2:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{}),"Input: m = 7, n = 3\nOutput: 28\n")),Object(r.b)("h1",{id:"solution"},"Solution"),Object(r.b)(o.a,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Python",value:"py"}],mdxType:"Tabs"},Object(r.b)(m.a,{value:"java",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"class Solution {\n    public int uniquePaths(int m, int n) {\n        if(m == 0|| n==0) return 0;\n        int[][] dp = new int[m][n];\n        for(int i = 0; i < m; i++){\n            dp[i][n-1] = 1;\n        }\n        for(int i = 0; i < n; i++){\n            dp[m-1][i] = 1;\n        }\n        for(int j = m-2; j>=0; j--){\n            for(int i = n-2; i>=0;i--){\n                dp[j][i] = dp[j+1][i] + dp[j][i+1];\n            }\n        }\n        return dp[0][0];\n    }\n}\n"))),Object(r.b)(m.a,{value:"py",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-py"}),"class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        if not m or not n:\n            return 0\n\n        paths = [[1]*(n+1)]*(m +1)\n\n        for i in range(2,m+1):\n            for j in range(2, n+1):\n                paths[i][j] = paths[i-1][j] + paths[i][j-1]\n\n        return paths[m][n]\n")))))}p.isMDXComponent=!0},57:function(n,e,t){"use strict";t.r(e),t.d(e,"frontMatter",(function(){return u})),t.d(e,"metadata",(function(){return l})),t.d(e,"toc",(function(){return c})),t.d(e,"default",(function(){return p}));var i=t(147),a=t(149),r=(t(0),t(148)),o=t(151),m=t(152),u={title:"Leetcode 64. Minimum Path Sum",tags:["DynamicProgramming/Coordinate"]},l={unversionedId:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/64-minimum-path-sum",id:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/64-minimum-path-sum",isDocsHomePage:!1,title:"Leetcode 64. Minimum Path Sum",description:"Question Description",source:"@site/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/64-minimum-path-sum.md",slug:"/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/64-minimum-path-sum",permalink:"/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/64-minimum-path-sum",version:"current"},c=[{value:"Example:",id:"example",children:[]}],s={toc:c};function p(n){var e=n.components,u=Object(a.a)(n,["components"]);return Object(r.b)("wrapper",Object(i.a)({},s,u,{components:e,mdxType:"MDXLayout"}),Object(r.b)("p",null,Object(r.b)("img",{src:t(194).default})),Object(r.b)("h1",{id:"question-description"},"Question Description"),Object(r.b)("p",null,"Original Question: ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://leetcode.com/problems/minimum-path-sum/"}),"Leetcode 64. Minimum Path Sum")),Object(r.b)("p",null,"Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path."),Object(r.b)("p",null,"Note: You can only move either down or right at any point in time."),Object(r.b)("h3",{id:"example"},"Example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-aidl"}),"Input:\n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\nOutput: 7\nExplanation: Because the path 1\u21923\u21921\u21921\u21921 minimizes the sum.\n")),Object(r.b)("h1",{id:"solution"},"Solution"),Object(r.b)(o.a,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Python",value:"py"}],mdxType:"Tabs"},Object(r.b)(m.a,{value:"java",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"class Solution {\n    public int minPathSum(int[][] grid) {\n        if(grid.length == 0 || grid[0].length == 0) return 0;\n        int[][] dp = new int [grid.length][grid[0].length];\n        for(int i = 0; i<grid.length; i++){\n            for(int j = 0; j < grid[0].length; j++){\n                if(i==0 && j==0) dp[i][j] = grid[0][0];\n                else if(i==0) {\n                    dp[i][j] = grid[i][j] + dp[i][j-1];\n                } else if (j == 0){\n                    dp[i][j] = grid[i][j] + dp[i-1][j];\n                } else {\n                    dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);\n                }\n            }\n        }\n        return dp[grid.length-1][grid[0].length-1];\n    }\n}\n"))),Object(r.b)(m.a,{value:"py",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-py"}),"class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n\n        m,n = len(grid), len(grid[0])\n\n\n        minSum = [[0 for j in range(n)] for i in range(m) ] \n        minSum[0][0] = grid[0][0]\n\n        for i in range(1,m):\n            minSum[i][0] = minSum[i-1][0] + grid[i][0]\n\n        for j in range(1,n):\n            minSum[0][j] = minSum[0][j-1] + grid[0][j]\n\n        for i in range(1,m):\n            for j in range(1,n):\n                minSum[i][j] = min(minSum[i-1][j], minSum[i][j-1]) + grid[i][j]\n\n        return minSum[m-1][n-1]\n")))))}p.isMDXComponent=!0},59:function(n,e,t){"use strict";t.r(e),t.d(e,"frontMatter",(function(){return u})),t.d(e,"metadata",(function(){return l})),t.d(e,"toc",(function(){return c})),t.d(e,"default",(function(){return p}));var i=t(147),a=t(149),r=(t(0),t(148)),o=t(151),m=t(152),u={title:"Leetcode 63. Unique Paths II",tags:["DynamicProgramming/Coordinate"]},l={unversionedId:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/63-unique-paths-ii",id:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/63-unique-paths-ii",isDocsHomePage:!1,title:"Leetcode 63. Unique Paths II",description:"Question Description",source:"@site/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/63-unique-paths-ii.md",slug:"/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/63-unique-paths-ii",permalink:"/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/63-unique-paths-ii",version:"current"},c=[{value:"Example:",id:"example",children:[]}],s={toc:c};function p(n){var e=n.components,u=Object(a.a)(n,["components"]);return Object(r.b)("wrapper",Object(i.a)({},s,u,{components:e,mdxType:"MDXLayout"}),Object(r.b)("p",null,Object(r.b)("img",{src:t(198).default})),Object(r.b)("h1",{id:"question-description"},"Question Description"),Object(r.b)("p",null,"Original Question: ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://leetcode.com/problems/unique-paths-ii/"}),"Leetcode 63. Unique Paths II")),Object(r.b)("p",null,"A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below)."),Object(r.b)("p",null,"The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below)."),Object(r.b)("p",null,"Now consider if some obstacles are added to the grids. How many unique paths would there be?"),Object(r.b)("h3",{id:"example"},"Example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-aidl"}),"Input:\n[\n  [0,0,0],\n  [0,1,0],\n  [0,0,0]\n]\nOutput: 2\nExplanation:\nThere is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n")),Object(r.b)("h1",{id:"solution"},"Solution"),Object(r.b)(o.a,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Python",value:"py"}],mdxType:"Tabs"},Object(r.b)(m.a,{value:"java",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"class Solution {\n    public int uniquePaths(int m, int n) {\n        if(m == 0|| n==0) return 0;\n        int[][] dp = new int[m][n];\n        for(int i = 0; i < m; i++){\n            dp[i][n-1] = 1;\n        }\n        for(int i = 0; i < n; i++){\n            dp[m-1][i] = 1;\n        }\n        for(int j = m-2; j>=0; j--){\n            for(int i = n-2; i>=0;i--){\n                dp[j][i] = dp[j+1][i] + dp[j][i+1];\n            }\n        }\n        return dp[0][0];\n    }\n}\n"))),Object(r.b)(m.a,{value:"py",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-py"}),"class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        if not m or not n:\n            return 0\n\n        paths = [[1]*(n+1)]*(m +1)\n\n        for i in range(2,m+1):\n            for j in range(2, n+1):\n                paths[i][j] = paths[i-1][j] + paths[i][j-1]\n\n        return paths[m][n]\n")))))}p.isMDXComponent=!0},60:function(n,e,t){"use strict";t.r(e),t.d(e,"frontMatter",(function(){return u})),t.d(e,"metadata",(function(){return l})),t.d(e,"toc",(function(){return c})),t.d(e,"default",(function(){return p}));var i=t(147),a=t(149),r=(t(0),t(148)),o=t(151),m=t(152),u={title:"Leetcode 931. Minimum Falling Path Sum",tags:["DynamicProgramming/Coordinate"]},l={unversionedId:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/931-minimum-falling-path-sum",id:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/931-minimum-falling-path-sum",isDocsHomePage:!1,title:"Leetcode 931. Minimum Falling Path Sum",description:"Question Description",source:"@site/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/931-minimum-falling-path-sum.md",slug:"/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/931-minimum-falling-path-sum",permalink:"/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/931-minimum-falling-path-sum",version:"current"},c=[{value:"Example:",id:"example",children:[]}],s={toc:c};function p(n){var e=n.components,u=Object(a.a)(n,["components"]);return Object(r.b)("wrapper",Object(i.a)({},s,u,{components:e,mdxType:"MDXLayout"}),Object(r.b)("p",null,Object(r.b)("img",{src:t(199).default})),Object(r.b)("h1",{id:"question-description"},"Question Description"),Object(r.b)("p",null,"Original Question: ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://leetcode.com/problems/minimum-falling-path-sum/"}),"931. Minimum Falling Path Sum")),Object(r.b)("p",null,"Given a square array of integers A, we want the minimum sum of a falling path through A."),Object(r.b)("p",null,"A falling path starts at any element in the first row, and chooses one element from each row.  The next row's choice must be in a column that is different from the previous row's column by at most one."),Object(r.b)("h3",{id:"example"},"Example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-aidl"}),"Input: [[1,2,3],[4,5,6],[7,8,9]]\nOutput: 12\nExplanation: \nThe possible falling paths are:\n- [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]\n- [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]\n- [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]\n\nThe falling path with the smallest sum is [1,4,7], so the answer is 12.\n\n")),Object(r.b)("h1",{id:"solution"},"Solution"),Object(r.b)(o.a,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Python",value:"py"}],mdxType:"Tabs"},Object(r.b)(m.a,{value:"java",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"class Solution {\n    public int minFallingPathSum(int[][] A) {\n        int m = A.length, n = A[0].length;\n        int[][] dp = new int[m][n];\n        for(int i = 0; i < n; i++){\n            dp[0][i] = A[0][i];\n        }\n        for(int i = 1; i < m; i++){\n            for(int j = 0; j < n; j++){\n                int topLeft = j-1 < 0 ? Integer.MAX_VALUE : dp[i-1][j-1];\n                int topMid = dp[i-1][j];\n                int topRight = j+1 >= n ? Integer.MAX_VALUE : dp[i-1][j+1];\n                dp[i][j] = A[i][j] + Math.min(topLeft, Math.min(topMid, topRight));\n            }\n        }\n        int smallestPath = Integer.MAX_VALUE;\n        for(int i = 0; i < n; i++){\n            smallestPath = Math.min(smallestPath, dp[m-1][i]);\n        }\n        return smallestPath;\n    }\n}\n"))),Object(r.b)(m.a,{value:"py",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-py"}),"class Solution:\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\n        for i in range(1,len(A)):\n            for j in range(len(A[0])):\n                if j == 0:\n                    A[i][j]  = min((A[i][j] + A[i - 1][j]), (A[i][j] + A[i - 1][j + 1]) )\n                elif (j == len(A[0]) - 1):\n                    A[i][j]  = min((A[i][j] + A[i - 1][j]), (A[i][j] + A[i - 1][j - 1]) )\n                else:\n                    A[i][j] = min(A[i][j] + A[i - 1][j],A[i][j] + A[i - 1][j + 1], A[i][j] + A[i - 1][j - 1])\n            \n        return min(A[len(A) - 1])\n")))))}p.isMDXComponent=!0}}]);