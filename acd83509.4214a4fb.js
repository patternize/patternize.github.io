(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{121:function(e,n,a){"use strict";a.r(n),a.d(n,"frontMatter",(function(){return c})),a.d(n,"metadata",(function(){return l})),a.d(n,"rightToc",(function(){return s})),a.d(n,"Backtracking",(function(){return u})),a.d(n,"default",(function(){return b}));var t=a(1),r=a(6),i=(a(0),a(145)),o=a(161),c={id:"README",title:"Introduction to Backtracking",sidebar_label:"Introduction to Backtracking"},l={id:"Patterns/Backtracking/README",title:"Introduction to Backtracking",description:"import { Hierarchy } from '@patternize/components'",source:"@site/docs/Patterns/Backtracking/README.md",permalink:"/docs/Patterns/Backtracking/README",sidebar_label:"Introduction to Backtracking",sidebar:"Patterns",previous:{title:"Preface",permalink:"/docs/Patterns/README"},next:{title:"Permutation of Elements",permalink:"/docs/Patterns/Backtracking/Permutation/Permutation"}},s=[{value:"Backtracking",id:"backtracking",children:[]},{value:"Intuitions of A Backtracking Problem",id:"intuitions-of-a-backtracking-problem",children:[]},{value:"Backtracking Generalized Solution Template",id:"backtracking-generalized-solution-template",children:[]},{value:"References",id:"references",children:[]}],u=function(){return Object(i.b)(o.Hierarchy,{tree:{name:"\ud83e\udd43",children:[{name:"Bourbon",children:[{name:"Mint",children:[{name:"Mint Julep"}]},{name:"Vermouth",children:[{name:"Manhattan"}]},{name:"Lime",children:[{name:"Cherry",children:[{name:"Whiskey Sour"}]}]},{name:"Ice Cube",children:[{name:"Orange Peel",children:[{name:"Old Fashioned"}]}]}]},{name:"Vodka",children:[{name:"Tomato",children:[{name:"Bloody Mary"}]},{name:"Kahlua",children:[{name:"Cream",children:[{name:"White Russian"}]}]},{name:"Cranberry",children:[{name:"Grapefruit",children:[{name:"Sea Breeze"},{name:"Lime",children:[{name:"Cosmopolitan"}]}]}]}]},{name:"Rum",children:[{name:"Pineapple",children:[{name:"Coconut",children:[{name:"Pina Colada"}]}]},{name:"Lime",children:[{name:"Mojito"},{name:"Cola",children:[{name:"Cuba Libre"}]}]}]}]},mdxType:"Hierarchy"})},m={rightToc:s,Backtracking:u};function b(e){var n=e.components,a=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(t.a)({},m,a,{components:n,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Have you ever run into these problems in your daily life?"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"For my luggage lock, what are some of the interesting password combination I can come up with? \ud83d\udd10"),Object(i.b)("li",{parentName:"ul"},"For my living room, how many possible ways I can rearrange my sofa, table, speakers and TV? \ud83d\udcfa"),Object(i.b)("li",{parentName:"ul"},"Or, yes! this is a good one, given a set of liquors and juice, what are possible cocktails I can come up with? \ud83c\udf79")),Object(i.b)(u,{mdxType:"Backtracking"}),Object(i.b)("h2",{id:"backtracking"},"Backtracking"),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},'"Backtracking can be defined as a general algorithmic technique that considers searching every possible combination in order to solve a computational problem."')),Object(i.b)("h2",{id:"intuitions-of-a-backtracking-problem"},"Intuitions of A Backtracking Problem"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},'The problem is about combinations, combinatorics, and permutation. Usually the problem has multiple possible solutions and it asks you to "list" or "enumerate" all the possible solutions.'),Object(i.b)("li",{parentName:"ol"},"When you try to come up with an combination of both iteration and recursion. For example, you need to have a loop inside of a recursive function, and the loop's range depends on the function parameters:")),Object(i.b)("pre",null,Object(i.b)("code",Object(t.a)({parentName:"pre"},{className:"language-java"}),"void someRecursiveFunction(int x, int y){\n    /* do something... */\n    for(int i = 0; i < y; i++){\n        /* do something in the for loop... */\n        // call someRecursiveFunction with updated parameters\n        someRecursiveFunction(x, y+i);\n    }\n    /* do something else... */\n}\n")),Object(i.b)("ol",{start:3},Object(i.b)("li",{parentName:"ol"},"When you can prove that the solution needs a runtime of ",Object(i.b)("img",{src:"https://render.githubusercontent.com/render/math?math=O(n!)"}))),Object(i.b)("h2",{id:"backtracking-generalized-solution-template"},"Backtracking Generalized Solution Template"),Object(i.b)("pre",null,Object(i.b)("code",Object(t.a)({parentName:"pre"},{className:"language-java"}),"class Solution {\n    /* Declare private data structures: */\n    private ArrayList<Integer> solutions;\n    public List<List<Integer>> permute(int[] nums) {\n        // declare private data structures\n        solutions = new ArrayList<>();\n        // call backtrack\n        backtrack(param1, param2);\n        // return results\n        return this.results;\n    }\n\n    private void backtrack(int param1, int param2){\n        // handle base case!\n        if(BaseCase qualified){\n            // Add current result to the solution collection\n            solutions.add(param2)\n            return;\n        }\n\n        for(int i = 0; i< param1; i++){\n            // 1. Handle edge case\n            if(count[i] == 0) continue;\n            // 2. Prepare a possible solution using some variable\n            result.set(level, nums[i]);\n            // 3. Remove used variable in step 2\n            count[i]--;\n            // 4. Call backtrack recursively\n            backtrack(param1, param2+1);\n            // 5. Add used variable in step 2 and 4 back to the set\n            count[i]++;\n        }\n    }\n}\n")),Object(i.b)("h2",{id:"references"},"References"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(t.a)({parentName:"li"},{href:"https://www.geeksforgeeks.org/backtracking-introduction/"}),"Geeksforgeeks: Intro to Backtracking"))))}b.isMDXComponent=!0}}]);