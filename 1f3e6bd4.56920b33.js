(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{149:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return b}));var r=n(0),l=n.n(r);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,l=function(e,t){if(null==e)return{};var n,r,l={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=l.a.createContext({}),u=function(e){var t=l.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=u(e.components);return l.a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return l.a.createElement(l.a.Fragment,{},t)}},f=l.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,o=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),d=u(n),f=r,b=d["".concat(o,".").concat(f)]||d[f]||p[f]||a;return n?l.a.createElement(b,i(i({ref:t},s),{},{components:n})):l.a.createElement(b,i({ref:t},s))}));function b(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=f;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var s=2;s<a;s++)o[s]=n[s];return l.a.createElement.apply(null,o)}return l.a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},150:function(e,t,n){"use strict";function r(e){var t,n,l="";if("string"==typeof e||"number"==typeof e)l+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=r(e[t]))&&(l&&(l+=" "),l+=n);else for(t in e)e[t]&&(l&&(l+=" "),l+=t);return l}t.a=function(){for(var e,t,n=0,l="";n<arguments.length;)(e=arguments[n++])&&(t=r(e))&&(l&&(l+=" "),l+=t);return l}},151:function(e,t,n){"use strict";var r=n(0),l=n.n(r),a=n(153),o=n(150),i=n(55),c=n.n(i);const s=37,u=39;t.a=function(e){const{lazy:t,block:n,defaultValue:i,values:d,groupId:p,className:f}=e,{tabGroupChoices:b,setTabGroupChoices:v}=Object(a.a)(),[h,m]=Object(r.useState)(i),g=r.Children.toArray(e.children);if(null!=p){const e=b[p];null!=e&&e!==h&&d.some((t=>t.value===e))&&m(e)}const O=e=>{m(e),null!=p&&v(p,e)},y=[];return l.a.createElement("div",null,l.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(o.a)("tabs",{"tabs--block":n},f)},d.map((({value:e,label:t})=>l.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":h===e,className:Object(o.a)("tabs__item",c.a.tabItem,{"tabs__item--active":h===e}),key:e,ref:e=>y.push(e),onKeyDown:e=>{((e,t,n)=>{switch(n.keyCode){case u:((e,t)=>{const n=e.indexOf(t)+1;e[n]?e[n].focus():e[0].focus()})(e,t);break;case s:((e,t)=>{const n=e.indexOf(t)-1;e[n]?e[n].focus():e[e.length-1].focus()})(e,t)}})(y,e.target,e)},onFocus:()=>O(e),onClick:()=>{O(e)}},t)))),t?Object(r.cloneElement)(g.filter((e=>e.props.value===h))[0],{className:"margin-vert--md"}):l.a.createElement("div",{className:"margin-vert--md"},g.map(((e,t)=>Object(r.cloneElement)(e,{key:t,hidden:e.props.value!==h})))))}},152:function(e,t,n){"use strict";var r=n(3),l=n(0),a=n.n(l);t.a=function({children:e,hidden:t,className:n}){return a.a.createElement("div",Object(r.a)({role:"tabpanel"},{hidden:t,className:n}),e)}},153:function(e,t,n){"use strict";var r=n(0),l=n(154);t.a=function(){const e=Object(r.useContext)(l.a);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},154:function(e,t,n){"use strict";var r=n(0);const l=Object(r.createContext)(void 0);t.a=l},83:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return u})),n.d(t,"default",(function(){return p}));var r=n(3),l=n(7),a=(n(0),n(149)),o=n(151),i=n(152),c={id:"LC103",title:"LC103. Binary Tree Zigzag Level Order Traversal",sidebar_label:"LC103. Binary Tree Zigzag Level Order Traversal",tags:["Patterns/Tree","DataStructures/Tree"]},s={unversionedId:"QuestionBank/Leetcode/LC103",id:"QuestionBank/Leetcode/LC103",isDocsHomePage:!1,title:"LC103. Binary Tree Zigzag Level Order Traversal",description:"Problem Description",source:"@site/docs/QuestionBank/Leetcode/103. Binary Tree Zigzag Level Order Traversal.md",slug:"/QuestionBank/Leetcode/LC103",permalink:"/docs/QuestionBank/Leetcode/LC103",version:"current",sidebar_label:"LC103. Binary Tree Zigzag Level Order Traversal",sidebar:"Data Structure",previous:{title:"LC101. Symmetric Tree",permalink:"/docs/QuestionBank/Leetcode/LC101"},next:{title:"LC108. Convert Sorted Array to Binary Search Tree",permalink:"/docs/QuestionBank/Leetcode/LC108"}},u=[{value:"Problem Description",id:"problem-description",children:[]},{value:"Solution",id:"solution",children:[{value:"High level strategy",id:"high-level-strategy",children:[]},{value:"Code",id:"code",children:[]}]},{value:"Other Solutions",id:"other-solutions",children:[]}],d={toc:u};function p(e){var t=e.components,n=Object(l.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},d,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"problem-description"},"Problem Description"),Object(a.b)("p",null,"Source: ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/"}),"https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/")),Object(a.b)("p",null,"Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between)."),Object(a.b)("p",null,"For example:\nGiven binary tree ","[3, 9, 20, null, null, 15, 7]",","),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{}),"    3\n   / \\\n  9  20\n    /  \\\n   15   7\n")),Object(a.b)("p",null,"return its zigzag level order traversal as: [","[3]",", ","[20, 9]",", ","[15, 7]","]."),Object(a.b)("h2",{id:"solution"},"Solution"),Object(a.b)("h3",{id:"high-level-strategy"},"High level strategy"),Object(a.b)("p",null,"Our strategy to solve this problem will be to conduct a breadth-first search. However, unlike an ordinary breadth-first search, we will only traverse from the left to right on even levels (including zero), and from the right to left on odd levels. The time complexity of this solution is ",Object(a.b)("strong",{parentName:"p"},"O(n)"),", where 'n' is equal to the number of nodes. The space complexity of this solution is ",Object(a.b)("strong",{parentName:"p"},"O(logn)"),", or ",Object(a.b)("strong",{parentName:"p"},"O(h)"),", where 'h' is equal to the height of the tree."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{}),"    3   level 0; traverse from left to right [3]\n   / \\\n  9  20   level 1; traverse from right to left [20, 9]\n    /  \\\n   15   7   level 2; traverse from left to right [15, 7]\n")),Object(a.b)("h3",{id:"code"},"Code"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-javascript"}),"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n **/\n\nconst zigzagLevelOrder = (root) => {\n    let result = [];\n    \n    let recurse = (node, level) => {\n        if (node === null) return;\n        if (!result[level]) {\n            result[level] = [];\n        }\n        \n        if (level % 2 === 0) {\n            result[level].push(node.val); // left to right traversal is implemented with the push method\n        } else {\n            result[level].unshift(node.val); // right to left traversal is implemented with the unshift method\n        }\n        \n        recurse(node.left, level + 1);\n        recurse(node.right, level + 1);\n    };\n    \n    \n    recurse(root, 0);\n    return result;\n};\n")),Object(a.b)("h2",{id:"other-solutions"},"Other Solutions"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"We can potentially use a deque, insert it at head for odd levels, and tail for even levels")),Object(a.b)(o.a,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Python",value:"py"}],mdxType:"Tabs"},Object(a.b)(i.a,{value:"java",mdxType:"TabItem"},Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),"class Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n            List<List<Integer>> toRet = new ArrayList<>();\n            if (root == null) return toRet;\n            Queue<TreeNode> queue = new LinkedList<>();\n            queue.add(root);\n            int count;\n            boolean leftToRight = true;\n            while(!queue.isEmpty()){\n                count = queue.size();\n                ArrayList<Integer> level = new ArrayList<>();\n                for (int i = 0; i < count; i ++){\n                    TreeNode node = queue.poll();\n                    if(leftToRight) {\n                        level.add(node.val);\n                    } else {\n                        level.add(0, node.val);\n                    }\n                    if(node.left != null){\n                        queue.add(node.left);\n                    }\n                    if(node.right != null){\n                        queue.add(node.right);\n                    }\n                }\n                leftToRight = !leftToRight;\n                toRet.add(level);\n            }\n            return toRet;\n        }\n}\n"))),Object(a.b)(i.a,{value:"py",mdxType:"TabItem"},Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-py"}),'class Solution(object):\n    def zigzagLevelOrder(self, root):\n        """\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        """\n        if not root: \n            return []\n        leftToRight = True \n        dq = collections.deque() \n        dq.append(root)\n        traversal = [] \n        while len(dq) > 0:\n            level = []\n            for i in range(len(dq)):\n                if leftToRight:\n                    cur = dq.popleft()\n                    level.append(cur.val)\n                    if cur.left:\n                        dq.append(cur.left)\n                    if cur.right:\n                        dq.append(cur.right)\n                else:\n                    cur = dq.pop()\n                    level.append(cur.val)\n                    if cur.right:\n                        dq.appendleft(cur.right)\n                    if cur.left:\n                        dq.appendleft(cur.left)\n            traversal.append(level)\n            leftToRight = not leftToRight\n        return traversal\n')))))}p.isMDXComponent=!0}}]);