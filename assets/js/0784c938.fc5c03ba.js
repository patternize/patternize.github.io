"use strict";(self.webpackChunkpatternize_io=self.webpackChunkpatternize_io||[]).push([[7053],{8478:(e,r,t)=>{t.d(r,{A:()=>s});var n=t(6540),a=t(2303);function s(e){let{children:r,fallback:t}=e;return(0,a.A)()?n.createElement(n.Fragment,null,null==r?void 0:r()):null!=t?t:null}},186:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>f,contentTitle:()=>u,default:()=>g,frontMatter:()=>h,metadata:()=>d,toc:()=>c});var n=t(8168),a=t(8587),s=(t(6540),t(5680)),i=t(9926),o=t(8478);const l=["components"],h={id:"BSTTraversals",title:"Traversals",sidbar_label:"Traversals"},u=void 0,d={unversionedId:"DataStructures/Basic/BinaryTree/BSTTraversals",id:"DataStructures/Basic/BinaryTree/BSTTraversals",title:"Traversals",description:"When we traverse a m-ary tree or a binary tree, we can either visit the deepest nodes first, or every node on the top-most level first. The former is called depth-first search (DFS), and the latter is called breadth-first search (BFS). For trees in particular, since trees are a subset of graphs, depth-first search can be done in three ways. These are pre-order, in-order, and post-order traversals. Hence, there are a total of four different forms of tree traversals.",source:"@site/docs/DataStructures/Basic/BinaryTree/BSTTraversals.md",sourceDirName:"DataStructures/Basic/BinaryTree",slug:"/DataStructures/Basic/BinaryTree/BSTTraversals",permalink:"/docs/DataStructures/Basic/BinaryTree/BSTTraversals",draft:!1,tags:[],version:"current",frontMatter:{id:"BSTTraversals",title:"Traversals",sidbar_label:"Traversals"},sidebar:"Data Structure",previous:{title:"Definition and Properties",permalink:"/docs/DataStructures/Basic/BinaryTree/Definitions&&Properties"},next:{title:"Basic Operations",permalink:"/docs/DataStructures/Basic/BinaryTree/BSTOperations"}},f={},c=[{value:"Breadth-First Search (BFS)",id:"breadth-first-search-bfs",level:3},{value:"Depth-First Search (DFS)",id:"depth-first-search-dfs",level:3},{value:"Pre-order, In-order, and Post-order Traversals",id:"pre-order-in-order-and-post-order-traversals",level:4}],p={toc:c},m="wrapper";function g(e){let{components:r}=e,t=(0,a.A)(e,l);return(0,s.yg)(m,(0,n.A)({},p,t,{components:r,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When we traverse a ",(0,s.yg)("em",{parentName:"p"},"m"),"-ary tree or a binary tree, we can either visit the deepest nodes first, or every node on the top-most level first. The former is called ",(0,s.yg)("em",{parentName:"p"},"depth-first search")," (DFS), and the latter is called ",(0,s.yg)("em",{parentName:"p"},"breadth-first search")," (BFS). For trees in particular, since trees are a subset of graphs, depth-first search can be done in three ways. These are ",(0,s.yg)("em",{parentName:"p"},"pre-order"),", ",(0,s.yg)("em",{parentName:"p"},"in-order"),", and ",(0,s.yg)("em",{parentName:"p"},"post-order")," traversals. Hence, there are a total of four different forms of tree traversals. "),(0,s.yg)("h3",{id:"breadth-first-search-bfs"},"Breadth-First Search (BFS)"),(0,s.yg)("p",null,"Typically speaking, breadth-first search is implemented in the form of a queue. This is because we want to visit all nodes on the current level before we move on to the next. With a queue, we can push the children of the current node to the end of the queue, so that the children can be processed last. To implement this, we can initialize a queue with the root node of the tree. As we perform whatever logic we need, we dequeue the current node from the queue, and enqueue the current node's children. This process is then repeated on to the children of the current node. It can be implemented both recursively and iteratively. "),(0,s.yg)(o.A,{mdxType:"BrowserOnly"},(()=>(0,s.yg)(i.PC,{mdxType:"BTBFSTraversalStory"}))),(0,s.yg)("br",null),(0,s.yg)("details",null,(0,s.yg)("summary",null,"BFS Code Implementation"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-javascript"},"// return a bfs traversal of a binary tree in the form of an array;\n\n// definition for a binary tree node\n// function TreeNode(value, left, right) {\n//     this.value = value === undefined ? 0 : value;\n//     this.left = left === undefined ? null : left;\n//     this.right = right === undefined ? null : right;\n// }\n\nconst bfs_iterative = (root) => {\n    let queue = [root]; // our queue is implemented in the form of an array\n    let result = [];\n\n    while (queue.length) {\n        let current = queue.shift(); // dequeue is implemented in the form of the shift method\n        result.push(current.val);\n        queue.push(current.left); // enqueue is implemented in the form of the push method\n        queue.push(current.right);\n    }\n\n    return result;\n};\n\n// breadth-first search can also be done recursively, \n// though it is more commonly done iteratively\nconst bfs_recursive = (root) => {\n    let queue = [root]; \n    let result = [];\n    \n    let helper = (node) => {\n        if (node === null) return;\n        result.push(queue.shift().val); \n        if (node.left) queue.push(node.left);\n        if (node.right) queue.push(node.right);\n        helper(node.left); \n        helper(node.right);\n    };\n\n    helper(root);\n    return result;\n};\n"))),(0,s.yg)("h3",{id:"depth-first-search-dfs"},"Depth-First Search (DFS)"),(0,s.yg)("p",null,"Unlike breadth-first search, depth-first search processes the child nodes first. Therefore, it makes the most sense to think of depth-first search in the form of a stack. We can push the children of the current node onto a stack, and pop them to perform whatever logic we need before we come back to the current node. "),(0,s.yg)(o.A,{mdxType:"BrowserOnly"},(()=>(0,s.yg)(i.DX,{mdxType:"BTDFSTraversalStory"}))),(0,s.yg)("br",null),(0,s.yg)("details",null,(0,s.yg)("summary",null,"DFS Code Implementation"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-javascript"},"// return a dfs traversal of a binary tree in the form of an array;\n\n// definition for a binary tree node\n// function TreeNode(value, left, right) {\n//     this.value = value === undefined ? 0 : value;\n//     this.left = left === undefined ? null : left;\n//     this.right = right === undefined ? null : right;\n// }\n\nconst dfs_recursive = (root) => {\n    let stack = [root]; // our stack is implemented in the form of an array\n    let result = [];\n    \n    let helper = (node) => {\n        if (node === null) return;\n        result.push(queue.pop().val);\n        if (node.left) queue.push(node.left); \n        if (node.right) queue.push(node.right);\n        helper(node.left); \n        helper(node.right);\n    };\n\n    helper(root);\n    return result;\n};\n")),(0,s.yg)("p",null,"We can also implement depth-first search by using the call stack as our stack. This makes depth-first search much easier to implement with recursion."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-javascript"},"// return a dfs traversal of a binary tree in the form of an array;\n\n// definition for a binary tree node\n// function TreeNode(value, left, right) {\n//     this.value = value === undefined ? 0 : value;\n//     this.left = left === undefined ? null : left;\n//     this.right = right === undefined ? null : right;\n// }\n\nconst dfs_recursive = (root) => {\n    let result = [];\n    \n    let helper = (node) => {\n        if (node === null) return;\n        result.push(node.val);\n        helper(node.left); \n        helper(node.right);\n    };\n\n    helper(root);\n    return result;\n};\n"))),(0,s.yg)("h4",{id:"pre-order-in-order-and-post-order-traversals"},"Pre-order, In-order, and Post-order Traversals"),(0,s.yg)("p",null,"For trees, depth-first search can be done in three ways:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},"Preorder: Visit the root node first, then the left subtree, then the right subtree."),(0,s.yg)("li",{parentName:"ul"},"Inorder: Visit the left subtree first, then the root node, then the right subtree."),(0,s.yg)("li",{parentName:"ul"},"Postorder: Visit the left subtree first, then the right subtree, then the root node. ")),(0,s.yg)("p",null,"Thanks to the author of ",(0,s.yg)("a",{href:"https://github.com/jw642459986/fucking-algorithm/blob/english/think_like_computer/Framework%20and%20thoughts%20about%20learning%20data%20structure%20and%20algorithm.md"},"this article"),", the implementation of these three forms of traversals can be simplified into something like the following: "),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-javascript"},"const traverse = (root) => {\n    // preorder traversal\n    traverse(root.left);\n    // inorder traversal\n    traverse(root.right);\n    // postorder traversal\n};\n")))}g.isMDXComponent=!0}}]);