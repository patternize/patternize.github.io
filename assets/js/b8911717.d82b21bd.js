"use strict";(self.webpackChunkpatternize_io=self.webpackChunkpatternize_io||[]).push([[9619],{9365:(e,t,r)=>{r.d(t,{A:()=>l});var n=r(6540),o=r(53);const a={tabItem:"tabItem_Ymn6"};function l(e){let{children:t,hidden:r,className:l}=e;return n.createElement("div",{role:"tabpanel",className:(0,o.A)(a.tabItem,l),hidden:r},t)}},1470:(e,t,r)=>{r.d(t,{A:()=>w});var n=r(8168),o=r(6540),a=r(53),l=r(3104),s=r(6347),i=r(7485),u=r(1682),c=r(9466);function d(e){return function(e){var t,r;return null!=(t=null==(r=o.Children.map(e,(e=>{if(!e||(0,o.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:r.filter(Boolean))?t:[]}(e).map((e=>{let{props:{value:t,label:r,attributes:n,default:o}}=e;return{value:t,label:r,attributes:n,default:o}}))}function m(e){const{values:t,children:r}=e;return(0,o.useMemo)((()=>{const e=null!=t?t:d(r);return function(e){const t=(0,u.X)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error('Docusaurus error: Duplicate values "'+t.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[t,r])}function p(e){let{value:t,tabValues:r}=e;return r.some((e=>e.value===t))}function f(e){let{queryString:t=!1,groupId:r}=e;const n=(0,s.W6)(),a=function(e){let{queryString:t=!1,groupId:r}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=r?r:null}({queryString:t,groupId:r});return[(0,i.aZ)(a),(0,o.useCallback)((e=>{if(!a)return;const t=new URLSearchParams(n.location.search);t.set(a,e),n.replace(Object.assign({},n.location,{search:t.toString()}))}),[a,n])]}function h(e){const{defaultValue:t,queryString:r=!1,groupId:n}=e,a=m(e),[l,s]=(0,o.useState)((()=>function(e){var t;let{defaultValue:r,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(r){if(!p({value:r,tabValues:n}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+r+'" but none of its children has the corresponding value. Available values are: '+n.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return r}const o=null!=(t=n.find((e=>e.default)))?t:n[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:t,tabValues:a}))),[i,u]=f({queryString:r,groupId:n}),[d,h]=function(e){let{groupId:t}=e;const r=function(e){return e?"docusaurus.tab."+e:null}(t),[n,a]=(0,c.Dv)(r);return[n,(0,o.useCallback)((e=>{r&&a.set(e)}),[r,a])]}({groupId:n}),b=(()=>{const e=null!=i?i:d;return p({value:e,tabValues:a})?e:null})();(0,o.useLayoutEffect)((()=>{b&&s(b)}),[b]);return{selectedValue:l,selectValue:(0,o.useCallback)((e=>{if(!p({value:e,tabValues:a}))throw new Error("Can't select invalid tab value="+e);s(e),u(e),h(e)}),[u,h,a]),tabValues:a}}var b=r(2303);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function y(e){let{className:t,block:r,selectedValue:s,selectValue:i,tabValues:u}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,l.a_)(),m=e=>{const t=e.currentTarget,r=c.indexOf(t),n=u[r].value;n!==s&&(d(t),i(n))},p=e=>{var t;let r=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{var n;const t=c.indexOf(e.currentTarget)+1;r=null!=(n=c[t])?n:c[0];break}case"ArrowLeft":{var o;const t=c.indexOf(e.currentTarget)-1;r=null!=(o=c[t])?o:c[c.length-1];break}}null==(t=r)||t.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":r},t)},u.map((e=>{let{value:t,label:r,attributes:l}=e;return o.createElement("li",(0,n.A)({role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,key:t,ref:e=>c.push(e),onKeyDown:p,onClick:m},l,{className:(0,a.A)("tabs__item",g.tabItem,null==l?void 0:l.className,{"tabs__item--active":s===t})}),null!=r?r:t)})))}function v(e){let{lazy:t,children:r,selectedValue:n}=e;const a=(Array.isArray(r)?r:[r]).filter(Boolean);if(t){const e=a.find((e=>e.props.value===n));return e?(0,o.cloneElement)(e,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},a.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function T(e){const t=h(e);return o.createElement("div",{className:(0,a.A)("tabs-container",g.tabList)},o.createElement(y,(0,n.A)({},e,t)),o.createElement(v,(0,n.A)({},e,t)))}function w(e){const t=(0,b.A)();return o.createElement(T,(0,n.A)({key:String(t)},e))}},2924:(e,t,r)=>{r.r(t),r.d(t,{BinaryTree:()=>h,assets:()=>f,contentTitle:()=>m,default:()=>v,frontMatter:()=>d,metadata:()=>p,toc:()=>b});var n=r(8168),o=r(8587),a=r(6540),l=r(5680),s=r(3973),i=r(1470),u=r(9365);const c=["components"],d={id:"LC236",title:"Lowest Common Ancestor of a Binary Tree",sidebar_label:"Lowest Common Ancestor of a Binary Tree",tags:["Patterns/Tree","DataStructures/Tree"]},m=void 0,p={unversionedId:"DataStructures/Basic/BinaryTree/CommonProblems/LC236",id:"DataStructures/Basic/BinaryTree/CommonProblems/LC236",title:"Lowest Common Ancestor of a Binary Tree",description:"Problem Description",source:"@site/docs/DataStructures/Basic/BinaryTree/CommonProblems/236. Lowest Common Ancestor of a Binary Tree.md",sourceDirName:"DataStructures/Basic/BinaryTree/CommonProblems",slug:"/DataStructures/Basic/BinaryTree/CommonProblems/LC236",permalink:"/docs/DataStructures/Basic/BinaryTree/CommonProblems/LC236",draft:!1,tags:[{label:"Patterns/Tree",permalink:"/docs/tags/patterns-tree"},{label:"DataStructures/Tree",permalink:"/docs/tags/data-structures-tree"}],version:"current",sidebarPosition:236,frontMatter:{id:"LC236",title:"Lowest Common Ancestor of a Binary Tree",sidebar_label:"Lowest Common Ancestor of a Binary Tree",tags:["Patterns/Tree","DataStructures/Tree"]},sidebar:"Data Structure",previous:{title:"Binary Tree Right Side View",permalink:"/docs/DataStructures/Basic/BinaryTree/CommonProblems/LC199"},next:{title:"B Tree",permalink:"/docs/DataStructures/Basic/BTree/BTree"}},f={},h=()=>(0,l.yg)(a.Fragment,null,"undefined"!=typeof window&&(0,l.yg)(s.PH,{inputData:{name:"3",children:[{name:"5",children:[{name:"6"},{name:"2",children:[{name:"7"},{name:"4"}]}]},{name:"1",children:[{name:"0"},{name:"8"}]}]},maxHeight:250,mdxType:"Tree"})),b=[{value:"Problem Description",id:"problem-description",level:2},{value:"Solution",id:"solution",level:2},{value:"High level strategy",id:"high-level-strategy",level:3},{value:"Code",id:"code",level:3}],g={BinaryTree:h,toc:b},y="wrapper";function v(e){let{components:t}=e,r=(0,o.A)(e,c);return(0,l.yg)(y,(0,n.A)({},g,r,{components:t,mdxType:"MDXLayout"}),(0,l.yg)("h2",{id:"problem-description"},"Problem Description"),(0,l.yg)("p",null,"Given a binary tree, return the lowest common ancestor (LCA) of two given nodes in the tree."),(0,l.yg)("p",null,"According to the ",(0,l.yg)("a",{href:"https://en.wikipedia.org/wiki/Lowest_common_ancestor"},"definition of LCA on Wikipedia"),": \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow ",(0,l.yg)("strong",{parentName:"p"},"a node to be a descendant of itself"),").\u201d"),(0,l.yg)("p",null,"For example:\nGiven binary tree ","[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]",", where p = 5, and q = 1, return 3."),(0,l.yg)(h,{mdxType:"BinaryTree"}),(0,l.yg)("h2",{id:"solution"},"Solution"),(0,l.yg)("h3",{id:"high-level-strategy"},"High level strategy"),(0,l.yg)("p",null,"Our approach to this problem is to solve it recursively. In our base case, we return the current node if it is equal to 'p', 'q', or null. This way, we will receive falsy values as we recurse down a branch that does not contain either 'p' or 'q'. Therefore, if either the left or right side of the current node returns null, then we know that that side of the tree does not contain the target values, and we can simply check the opposite side. We repeat this process until we arrive at a subtree that contains both target values, at which point we return the root node of the subtree. The time complexity of this solution is ",(0,l.yg)("strong",{parentName:"p"},"O(n)"),", where 'n' is equal to the number of nodes. The space complexity is ",(0,l.yg)("strong",{parentName:"p"},"O(logn)"),", or ",(0,l.yg)("strong",{parentName:"p"},"O(h)"),", where 'h' is equal to the height of the tree."),(0,l.yg)("h3",{id:"code"},"Code"),(0,l.yg)(i.A,{defaultValue:"js",values:[{label:"Javascript",value:"js"},{label:"Java",value:"java"},{label:"Python",value:"py"}],mdxType:"Tabs"},(0,l.yg)(u.A,{value:"js",mdxType:"TabItem"},(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n **/\nconst lowestCommonAncestor = (root, p, q) => {\n  if (root === null || root === p || root === q) return root;\n  let left = lowestCommonAncestor(root.left, p, q);\n  let right = lowestCommonAncestor(root.right, p, q);\n\n  if (!left) return right;\n  if (!right) return left;\n\n  return root;\n};\n"))),(0,l.yg)(u.A,{value:"java",mdxType:"TabItem"},(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-java"},"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if(root == null || root == p || root == q) return root;\n    TreeNode left = lowestCommonAncestor(root.left, p, q);\n    TreeNode right = lowestCommonAncestor(root.right, p, q);\n    return left == null ? right : right == null ? left : root;\n}\n"))),(0,l.yg)(u.A,{value:"py",mdxType:"TabItem"},(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-python"},'# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        """\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        """\n\n        if not root:\n            return root\n\n        if root == p or root == q:\n            return root\n\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n\n        if left and right:\n            return root\n        else:\n            return left or right\n')))),(0,l.yg)("p",null,"Source: ",(0,l.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/"},"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/")))}v.isMDXComponent=!0}}]);