"use strict";(self.webpackChunkpatternize_io=self.webpackChunkpatternize_io||[]).push([[5460],{9365:(e,t,a)=>{a.d(t,{A:()=>o});var r=a(6540),n=a(53);const l={tabItem:"tabItem_Ymn6"};function o(e){let{children:t,hidden:a,className:o}=e;return r.createElement("div",{role:"tabpanel",className:(0,n.A)(l.tabItem,o),hidden:a},t)}},1470:(e,t,a)=>{a.d(t,{A:()=>w});var r=a(8168),n=a(6540),l=a(53),o=a(3104),i=a(6347),u=a(7485),s=a(1682),c=a(9466);function d(e){return function(e){var t,a;return null!=(t=null==(a=n.Children.map(e,(e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:a.filter(Boolean))?t:[]}(e).map((e=>{let{props:{value:t,label:a,attributes:r,default:n}}=e;return{value:t,label:a,attributes:r,default:n}}))}function m(e){const{values:t,children:a}=e;return(0,n.useMemo)((()=>{const e=null!=t?t:d(a);return function(e){const t=(0,s.X)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error('Docusaurus error: Duplicate values "'+t.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[t,a])}function h(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function p(e){let{queryString:t=!1,groupId:a}=e;const r=(0,i.W6)(),l=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=a?a:null}({queryString:t,groupId:a});return[(0,u.aZ)(l),(0,n.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(r.location.search);t.set(l,e),r.replace(Object.assign({},r.location,{search:t.toString()}))}),[l,r])]}function f(e){const{defaultValue:t,queryString:a=!1,groupId:r}=e,l=m(e),[o,i]=(0,n.useState)((()=>function(e){var t;let{defaultValue:a,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(a){if(!h({value:a,tabValues:r}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+a+'" but none of its children has the corresponding value. Available values are: '+r.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return a}const n=null!=(t=r.find((e=>e.default)))?t:r[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:l}))),[u,s]=p({queryString:a,groupId:r}),[d,f]=function(e){let{groupId:t}=e;const a=function(e){return e?"docusaurus.tab."+e:null}(t),[r,l]=(0,c.Dv)(a);return[r,(0,n.useCallback)((e=>{a&&l.set(e)}),[a,l])]}({groupId:r}),v=(()=>{const e=null!=u?u:d;return h({value:e,tabValues:l})?e:null})();(0,n.useLayoutEffect)((()=>{v&&i(v)}),[v]);return{selectedValue:o,selectValue:(0,n.useCallback)((e=>{if(!h({value:e,tabValues:l}))throw new Error("Can't select invalid tab value="+e);i(e),s(e),f(e)}),[s,f,l]),tabValues:l}}var v=a(2303);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function y(e){let{className:t,block:a,selectedValue:i,selectValue:u,tabValues:s}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,o.a_)(),m=e=>{const t=e.currentTarget,a=c.indexOf(t),r=s[a].value;r!==i&&(d(t),u(r))},h=e=>{var t;let a=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{var r;const t=c.indexOf(e.currentTarget)+1;a=null!=(r=c[t])?r:c[0];break}case"ArrowLeft":{var n;const t=c.indexOf(e.currentTarget)-1;a=null!=(n=c[t])?n:c[c.length-1];break}}null==(t=a)||t.focus()};return n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.A)("tabs",{"tabs--block":a},t)},s.map((e=>{let{value:t,label:a,attributes:o}=e;return n.createElement("li",(0,r.A)({role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,key:t,ref:e=>c.push(e),onKeyDown:h,onClick:m},o,{className:(0,l.A)("tabs__item",b.tabItem,null==o?void 0:o.className,{"tabs__item--active":i===t})}),null!=a?a:t)})))}function g(e){let{lazy:t,children:a,selectedValue:r}=e;const l=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=l.find((e=>e.props.value===r));return e?(0,n.cloneElement)(e,{className:"margin-top--md"}):null}return n.createElement("div",{className:"margin-top--md"},l.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==r}))))}function T(e){const t=f(e);return n.createElement("div",{className:(0,l.A)("tabs-container",b.tabList)},n.createElement(y,(0,r.A)({},e,t)),n.createElement(g,(0,r.A)({},e,t)))}function w(e){const t=(0,v.A)();return n.createElement(T,(0,r.A)({key:String(t)},e))}},2610:(e,t,a)=>{a.r(t),a.d(t,{BinaryTree:()=>f,assets:()=>p,contentTitle:()=>m,default:()=>g,frontMatter:()=>d,metadata:()=>h,toc:()=>v});var r=a(8168),n=a(8587),l=a(6540),o=a(5680),i=a(3973),u=a(1470),s=a(9365);const c=["components"],d={id:"LC98",title:"Validate Binary Search Tree",sidebar_label:"Validate Binary Search Tree",tags:["Patterns/Tree","DataStructures/Tree"]},m=void 0,h={unversionedId:"DataStructures/Basic/BinaryTree/CommonProblems/LC98",id:"DataStructures/Basic/BinaryTree/CommonProblems/LC98",title:"Validate Binary Search Tree",description:"Problem Description",source:"@site/docs/DataStructures/Basic/BinaryTree/CommonProblems/98. Validate Binary Search Tree.md",sourceDirName:"DataStructures/Basic/BinaryTree/CommonProblems",slug:"/DataStructures/Basic/BinaryTree/CommonProblems/LC98",permalink:"/DataStructures/Basic/BinaryTree/CommonProblems/LC98",draft:!1,tags:[{label:"Patterns/Tree",permalink:"/tags/patterns-tree"},{label:"DataStructures/Tree",permalink:"/tags/data-structures-tree"}],version:"current",sidebarPosition:98,frontMatter:{id:"LC98",title:"Validate Binary Search Tree",sidebar_label:"Validate Binary Search Tree",tags:["Patterns/Tree","DataStructures/Tree"]},sidebar:"Data Structure",previous:{title:"Basic Operations",permalink:"/DataStructures/Basic/BinaryTree/BSTOperations"},next:{title:"Symmetric Tree",permalink:"/DataStructures/Basic/BinaryTree/CommonProblems/LC101"}},p={},f=()=>(0,o.yg)(l.Fragment,null,"undefined"!=typeof window&&(0,o.yg)(i.PH,{inputData:{name:"5",children:[{name:"1"},{name:"12",children:[{name:"15"},{name:"16"}]}]},maxHeight:250,mdxType:"Tree"})),v=[{value:"Problem Description",id:"problem-description",level:2},{value:"Solution",id:"solution",level:2},{value:"High level strategy",id:"high-level-strategy",level:3},{value:"Code",id:"code",level:3}],b={BinaryTree:f,toc:v},y="wrapper";function g(e){let{components:t}=e,a=(0,n.A)(e,c);return(0,o.yg)(y,(0,r.A)({},b,a,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("h2",{id:"problem-description"},"Problem Description"),(0,o.yg)("p",null,"Source: ",(0,o.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/validate-binary-search-tree/"},"https://leetcode.com/problems/validate-binary-search-tree/")),(0,o.yg)("p",null,"Given the root of a binary tree, determine if it is a valid binary search tree (BST)."),(0,o.yg)("p",null,"A ",(0,o.yg)("strong",{parentName:"p"},"valid BST")," is defined as follows:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"The left subtree of a node contains only nodes with keys ",(0,o.yg)("strong",{parentName:"li"},"less than")," the node's key."),(0,o.yg)("li",{parentName:"ul"},"The right subtree of a node contains only nodes with keys ",(0,o.yg)("strong",{parentName:"li"},"greater than")," the node's key."),(0,o.yg)("li",{parentName:"ul"},"Both the left and right subtrees must also be binary search trees.")),(0,o.yg)("p",null,"For example: Given binary tree ","[5, 1, 12, null, null, 15, 16]",", return false, since 15 is the left child of 12, but is greater than 12."),(0,o.yg)(f,{mdxType:"BinaryTree"}),(0,o.yg)("h2",{id:"solution"},"Solution"),(0,o.yg)("h3",{id:"high-level-strategy"},"High level strategy"),(0,o.yg)("p",null,"To check whether a tree is a valid binary search tree, we must compare the value of the current node with the values of its parent or grandparent node. If the current node is the left child of its parent node, then its value cannot be greater than its parent. If the current node is the right child of its parent node, then its value cannot be lesser than its parent. Therefore, as we traverse down the binary search tree, we must pass the value of the current node as the minimum value or the maximum value against which the values of its children will be compared."),(0,o.yg)("p",null,"To implement our strategy, we will initialize the minimum value and the maximum value with null. We will keep the initial minimum value and pass the value of the current node as the maxmimum value as we recurse down the left side of the current node. We will keep the initial maximum value and pass the value of the current node as the minimum value as we recurse down the right side of the current node. We will return false if the minimum value is greater or equal to the value of the current node, and return false if the maximum value is lesser or equal to the value of the current node. We will only return true if we have reached the leaf of a tree, by which point the binary search tree invariant has yet to be violated. As we recurse back to the bottom-most level of the call stack, we expect both sides of the tree to return true, and we will only return true if and only if both sides return true. The time complexity of this solution is ",(0,o.yg)("strong",{parentName:"p"},"O(n)"),", where 'n' is equal to the number of nodes. The space complexity of this solution is ",(0,o.yg)("strong",{parentName:"p"},"O(h)"),", where h is equal to the height of the tree, which is equal to the log of 'n' on average, where 'n' is equal to the number of nodes. Therefore, the space complexity of this solution can also be expressed in the form of ",(0,o.yg)("strong",{parentName:"p"},"O(logn)"),"."),(0,o.yg)("h3",{id:"code"},"Code"),(0,o.yg)(u.A,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Javascript",value:"js"},{label:"Python",value:"py"}],mdxType:"Tabs"},(0,o.yg)(s.A,{value:"java",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public boolean isValidBST(TreeNode root) {\n        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n\n    public boolean isValidBST(TreeNode root, long minVal, long maxVal) {\n        if (root == null) return true;\n        if (root.val >= maxVal || root.val <= minVal) return false;\n        return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);\n    }\n}\n"))),(0,o.yg)(s.A,{value:"js",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n **/\n\nconst isValidBST = (root) => {\n  return helper(root, null, null);\n};\n\nconst helper = (node, min, max) => {\n  if (node === null) return true;\n  if (min !== null && min >= node.val) return false;\n  if (max !== null && max <= node.val) return false;\n\n  return helper(node.left, min, node.val) && helper(node.right, node.val, max);\n};\n"))),(0,o.yg)(s.A,{value:"py",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"def isValidBST(self, root: TreeNode) -> bool:\n    def validate(node, min_, max_):\n        if not node:\n            return True\n        if not (min_ < node.val < max_):\n            return False\n        return validate(node.left, min_, node.val) and validate(node.right, node.val, max_)\n    return validate(root,float('-inf'), float('inf'))\n")))))}g.isMDXComponent=!0}}]);