"use strict";(self.webpackChunkpatternize_io=self.webpackChunkpatternize_io||[]).push([[2527],{9365:(e,t,n)=>{n.d(t,{A:()=>o});var r=n(6540),a=n(53);const l={tabItem:"tabItem_Ymn6"};function o(e){let{children:t,hidden:n,className:o}=e;return r.createElement("div",{role:"tabpanel",className:(0,a.A)(l.tabItem,o),hidden:n},t)}},1470:(e,t,n)=>{n.d(t,{A:()=>w});var r=n(8168),a=n(6540),l=n(53),o=n(3104),i=n(6347),s=n(7485),u=n(1682),c=n(9466);function d(e){return function(e){var t,n;return null!=(t=null==(n=a.Children.map(e,(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:n.filter(Boolean))?t:[]}(e).map((e=>{let{props:{value:t,label:n,attributes:r,default:a}}=e;return{value:t,label:n,attributes:r,default:a}}))}function h(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=null!=t?t:d(n);return function(e){const t=(0,u.X)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error('Docusaurus error: Duplicate values "'+t.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[t,n])}function p(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:n}=e;const r=(0,i.W6)(),l=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=n?n:null}({queryString:t,groupId:n});return[(0,s.aZ)(l),(0,a.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(r.location.search);t.set(l,e),r.replace(Object.assign({},r.location,{search:t.toString()}))}),[l,r])]}function g(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,l=h(e),[o,i]=(0,a.useState)((()=>function(e){var t;let{defaultValue:n,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:r}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+n+'" but none of its children has the corresponding value. Available values are: '+r.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return n}const a=null!=(t=r.find((e=>e.default)))?t:r[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:l}))),[s,u]=m({queryString:n,groupId:r}),[d,g]=function(e){let{groupId:t}=e;const n=function(e){return e?"docusaurus.tab."+e:null}(t),[r,l]=(0,c.Dv)(n);return[r,(0,a.useCallback)((e=>{n&&l.set(e)}),[n,l])]}({groupId:r}),f=(()=>{const e=null!=s?s:d;return p({value:e,tabValues:l})?e:null})();(0,a.useLayoutEffect)((()=>{f&&i(f)}),[f]);return{selectedValue:o,selectValue:(0,a.useCallback)((e=>{if(!p({value:e,tabValues:l}))throw new Error("Can't select invalid tab value="+e);i(e),u(e),g(e)}),[u,g,l]),tabValues:l}}var f=n(2303);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function y(e){let{className:t,block:n,selectedValue:i,selectValue:s,tabValues:u}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,o.a_)(),h=e=>{const t=e.currentTarget,n=c.indexOf(t),r=u[n].value;r!==i&&(d(t),s(r))},p=e=>{var t;let n=null;switch(e.key){case"Enter":h(e);break;case"ArrowRight":{var r;const t=c.indexOf(e.currentTarget)+1;n=null!=(r=c[t])?r:c[0];break}case"ArrowLeft":{var a;const t=c.indexOf(e.currentTarget)-1;n=null!=(a=c[t])?a:c[c.length-1];break}}null==(t=n)||t.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.A)("tabs",{"tabs--block":n},t)},u.map((e=>{let{value:t,label:n,attributes:o}=e;return a.createElement("li",(0,r.A)({role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,key:t,ref:e=>c.push(e),onKeyDown:p,onClick:h},o,{className:(0,l.A)("tabs__item",v.tabItem,null==o?void 0:o.className,{"tabs__item--active":i===t})}),null!=n?n:t)})))}function b(e){let{lazy:t,children:n,selectedValue:r}=e;const l=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=l.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},l.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==r}))))}function T(e){const t=g(e);return a.createElement("div",{className:(0,l.A)("tabs-container",v.tabList)},a.createElement(y,(0,r.A)({},e,t)),a.createElement(b,(0,r.A)({},e,t)))}function w(e){const t=(0,f.A)();return a.createElement(T,(0,r.A)({key:String(t)},e))}},1030:(e,t,n)=>{n.r(t),n.d(t,{BinaryTree:()=>g,assets:()=>m,contentTitle:()=>h,default:()=>b,frontMatter:()=>d,metadata:()=>p,toc:()=>f});var r=n(8168),a=n(8587),l=n(6540),o=n(5680),i=n(8711),s=n(1470),u=n(9365);const c=["components"],d={id:"LC199",title:"Binary Tree Right Side View",sidebar_label:"Binary Tree Right Side View",tags:["Patterns/Tree","DataStructures/Tree"]},h=void 0,p={unversionedId:"DataStructures/Basic/BinaryTree/CommonProblems/LC199",id:"DataStructures/Basic/BinaryTree/CommonProblems/LC199",title:"Binary Tree Right Side View",description:"Problem Description",source:"@site/docs/DataStructures/Basic/BinaryTree/CommonProblems/199. Binary Tree Right Side View.md",sourceDirName:"DataStructures/Basic/BinaryTree/CommonProblems",slug:"/DataStructures/Basic/BinaryTree/CommonProblems/LC199",permalink:"/docs/DataStructures/Basic/BinaryTree/CommonProblems/LC199",draft:!1,tags:[{label:"Patterns/Tree",permalink:"/docs/tags/patterns-tree"},{label:"DataStructures/Tree",permalink:"/docs/tags/data-structures-tree"}],version:"current",sidebarPosition:199,frontMatter:{id:"LC199",title:"Binary Tree Right Side View",sidebar_label:"Binary Tree Right Side View",tags:["Patterns/Tree","DataStructures/Tree"]},sidebar:"Data Structure",previous:{title:"Convert Sorted Array to Binary Search Tree",permalink:"/docs/DataStructures/Basic/BinaryTree/CommonProblems/LC108"},next:{title:"Lowest Common Ancestor of a Binary Tree",permalink:"/docs/DataStructures/Basic/BinaryTree/CommonProblems/LC236"}},m={},g=()=>(0,o.yg)(l.Fragment,null,"undefined"!=typeof window&&(0,o.yg)(i.PH,{inputData:{name:"1",children:[{name:"2",children:[{name:"null"},{name:"6",children:[{name:"5"},{name:"null"}]}]},{name:"3",children:[{name:"null"},{name:"4"}]}]},maxHeight:250,mdxType:"Tree"})),f=[{value:"Problem Description",id:"problem-description",level:2},{value:"BFS Solution",id:"bfs-solution",level:2},{value:"High level strategy",id:"high-level-strategy",level:3},{value:"Code",id:"code",level:3},{value:"DFS Solutions",id:"dfs-solutions",level:2},{value:"High level strategy",id:"high-level-strategy-1",level:3},{value:"Code",id:"code-1",level:3}],v={BinaryTree:g,toc:f},y="wrapper";function b(e){let{components:t}=e,n=(0,a.A)(e,c);return(0,o.yg)(y,(0,r.A)({},v,n,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("h2",{id:"problem-description"},"Problem Description"),(0,o.yg)("p",null,"Source: ",(0,o.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/binary-tree-right-side-view/"},"https://leetcode.com/problems/binary-tree-right-side-view/")),(0,o.yg)("p",null,"Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom."),(0,o.yg)("p",null,"For example:\nGiven binary tree ","[1, 2, 3, null, 6, null, 4, null, null, 5]",", return ","[1, 3, 4, 5]","."),(0,o.yg)(g,{mdxType:"BinaryTree"}),(0,o.yg)("h2",{id:"bfs-solution"},"BFS Solution"),(0,o.yg)("h3",{id:"high-level-strategy"},"High level strategy"),(0,o.yg)("p",null,"Our strategy to solve this problem is to conduct a breadth-first search. On each level, we traverse from the left to right, but only keeping the value of the right-most node. To implement this solution, we will make use of the index property of arrays. The index of every element in the resulting array is the level of the corresponding right-most node on the tree. To see this, one can simply flip the tree on its side. The time complexity of this solution is ",(0,o.yg)("strong",{parentName:"p"},"O(n)"),", where 'n' is equal to the number of nodes. The space complexity of this solution is ",(0,o.yg)("strong",{parentName:"p"},"O(logn)"),", or ",(0,o.yg)("strong",{parentName:"p"},"O(h)"),", where 'h' is equal to the height of the tree."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"result: [1, 3, 4, 5];\n\n    1   <----- the right-most element is 1, which is equal to result[0];\n   / \\\n  2   3     <----- the right-most element is 3, which is equal to result[1];\n   \\   \\\n    6   4     <----- the right-most element is 4, which is equal to result[2];\n   /\n  5     <----- the right-most element is 5, which is equal to result[3];\n")),(0,o.yg)("h3",{id:"code"},"Code"),(0,o.yg)(s.A,{defaultValue:"js",values:[{label:"Javascript",value:"js"},{label:"Python",value:"py"}],mdxType:"Tabs"},(0,o.yg)(u.A,{value:"js",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n **/\n\nconst rightSideView = (root) => {\n  let result = [];\n\n  let recurse = (node, level) => {\n    if (node === null) return;\n    result[level] = node.val; // as we traverse from the left to right, the element on that level in the result array will be replaced with the right most node in the tree.\n    recurse(node.left, level + 1);\n    recurse(node.right, level + 1);\n  };\n\n  recurse(root, 0);\n  return result;\n};\n"))),(0,o.yg)(u.A,{value:"py",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"# Trick: Just store the lest element on each level\ndef rightSideView(self, root: TreeNode) -> List[int]:\n    if not root:\n        return []\n\n    trav, q = [], collections.deque([root])\n\n    while q:\n        cur = None\n        for i in range(len(q)):\n            cur = q.popleft()\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n        trav.append(cur.val)\n\n    return trav\n")))),(0,o.yg)("h2",{id:"dfs-solutions"},"DFS Solutions"),(0,o.yg)("h3",{id:"high-level-strategy-1"},"High level strategy"),(0,o.yg)("p",null,"We can modify the code and covert it into a DFS solution, the same concept applies."),(0,o.yg)("h3",{id:"code-1"},"Code"),(0,o.yg)(s.A,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Python",value:"py"},{label:"C++",value:"cp"}],mdxType:"Tabs"},(0,o.yg)(u.A,{value:"java",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer> ans = new LinkedList<>();\n        dfs(root, 1, ans);\n        return ans;\n    }\n\n    private void dfs(TreeNode node, int level, List<Integer> ans){\n        if(node == null){\n            return;\n        }\n        if(level > ans.size()){ // push current node to it\n            ans.add(node.val);\n        }\n        dfs(node.right, level+1, ans);\n        dfs(node.left, level+1, ans);\n    }\n}\n"))),(0,o.yg)(u.A,{value:"py",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"# Trick: Keep track of depth and update it via the traversal length. Make sure you stack left first then right to ensure properly visiting right first.\ndef rightSideView(self, root: TreeNode) -> List[int]:\n    if not root:\n        return []\n\n    s, maxdepth = [(root, 1)], -1\n    trav = []\n\n    while s:\n        cur, depth = s.pop()\n\n        if cur:\n            maxdepth = max(maxdepth, depth)\n\n        if len(trav) < depth:\n            trav.append(cur.val)\n\n        if cur.left:\n            s.append((cur.left, depth+1))\n        if cur.right:\n            s.append((cur.right, depth+1))\n    return trav\n"))),(0,o.yg)(u.A,{value:"cp",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"//C++\nclass Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) {\n        ans = {};\n        dfs(root, 1);\n        return ans;\n    }\n    void dfs(TreeNode* root, int h) {\n        if (root == nullptr) return;\n        if (ans.size() < h) {\n            ans.push_back(root->val);\n        }\n        dfs(root->right, h + 1);\n        dfs(root->left, h + 1);\n    }\nprivate:\n    vector<int> ans;\n};\n")))))}b.isMDXComponent=!0}}]);