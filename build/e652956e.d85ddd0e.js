(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{104:function(n,e,t){"use strict";t.r(e),t.d(e,"frontMatter",(function(){return r})),t.d(e,"metadata",(function(){return u})),t.d(e,"rightToc",(function(){return l})),t.d(e,"default",(function(){return b}));var i=t(1),o=t(6),a=(t(0),t(112)),r={id:"bit_manipulation",title:"Bit Manipulation",sidebar_label:"Bit Manipulation"},u={id:"DataStructure/bit_manipulation",title:"Bit Manipulation",description:"# Bit Manipulation",source:"@site/docs/DataStructure/Bit_Manipulation.md",permalink:"/docs/DataStructure/bit_manipulation",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/DataStructure/Bit_Manipulation.md",sidebar_label:"Bit Manipulation",sidebar:"doc",previous:{title:"Map",permalink:"/docs/DataStructure/map"},next:{title:"Powered by MDX",permalink:"/docs/mdx"}},l=[{value:"Power of 2:",id:"power-of-2",children:[]},{value:"Log Base of 2:",id:"log-base-of-2",children:[]},{value:"Count Ones",id:"count-ones",children:[]},{value:"References:",id:"references",children:[]}],c={rightToc:l},s="wrapper";function b(n){var e=n.components,t=Object(o.a)(n,["components"]);return Object(a.b)(s,Object(i.a)({},c,t,{components:e,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"bit-manipulation"},"Bit Manipulation"),Object(a.b)("h2",{id:"power-of-2"},"Power of 2:"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{}),"1 << x === 2^x\n")),Object(a.b)("h2",{id:"log-base-of-2"},"Log Base of 2:"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{}),"# log(a) base b = log(a)/log(b)\n32 >> 5 === log(32)/log(2) \n")),Object(a.b)("h2",{id:"count-ones"},"Count Ones"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"n&(n-1)")," rule: is used when you want to quickly count how many ",Object(a.b)("inlineCode",{parentName:"li"},"1s")," in your binary number, every-time you do ",Object(a.b)("inlineCode",{parentName:"li"},"n&(n-1)"),", a ",Object(a.b)("inlineCode",{parentName:"li"},"1")," in your binary form will be removed:\n// first run\nn = 23 // (10111)\nnMinusOne = n - 1 // === 22 (10110)\nn = n & nMinusOne // === 22 (10111 & 10110 = 10110)\n// second run\nnMinusOne = 22 - 1 // == 21 (10101)\nn = n & nMinusOne // == 20 (10110 & 10101 = 10101)\n// third run\nnMinusOne = 20 - 1 // == 19 (10011)\nn = n & nMinusOne // == 16 (10101 & 10011 = 10000)\n// fourth run\nnMinusOne = 16 - 1 // == 15 (01111)\nn = n & nMinusOne // == 0 (10000 & 01111 = 00000)\n// after 4 times, n becomes 0; hence there are 4 1s in your original binary form of int 23"),Object(a.b)("li",{parentName:"ul"},"in short:\nint count_one(int n) {\nwhile(n) {\nn = n&(n-1);\ncount++;\n}\nreturn count;\n}")),Object(a.b)("h2",{id:"references"},"References:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",Object(i.a)({parentName:"li"},{href:"https://leetcode.com/problems/sum-of-two-integers/discuss/84278/A-summary%3A-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently"}),"https://leetcode.com/problems/sum-of-two-integers/discuss/84278/A-summary%3A-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently"))))}b.isMDXComponent=!0}}]);