(window.webpackJsonp=window.webpackJsonp||[]).push([[56,7,37,51,66],{117:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return p})),t.d(n,"metadata",(function(){return d})),t.d(n,"rightToc",(function(){return b})),t.d(n,"default",(function(){return h}));var i=t(1),a=t(6),r=(t(0),t(131)),o=t(133),m=t(134),l=t(49),u=t(54),c=t(52),s=t(55),p={id:"index",title:"Optimal Path Finding Questions",sidebar_label:"Optimal Path Finding"},d={unversionedId:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/index",id:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/index",isDocsHomePage:!1,title:"Optimal Path Finding Questions",description:"<Tabs",source:"@site/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/index.md",permalink:"/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/index",sidebar_label:"Optimal Path Finding",sidebar:"Patterns",previous:{title:"Matrix Questions",permalink:"/docs/Patterns/DynamicProgramming/Coordinate/Matrix/index"},next:{title:"Bit Manipulation",permalink:"/docs/Patterns/BitManipulation/Introduction"}},b=[],g={rightToc:b};function h(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(i.a)({},g,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)(o.a,{defaultValue:"Unique Path",values:[{label:"Unique Path",value:"Unique Path"},{label:"Unique Path II",value:"Unique Path II"},{label:"Minimum Path Sum",value:"MinimumPathSum"},{label:"Minimum Falling Path Sum",value:"MinimumFallingPathSum"}],mdxType:"Tabs"},Object(r.b)(m.a,{value:"Unique Path",mdxType:"TabItem"},Object(r.b)(l.default,{mdxType:"UniquePaths"})),Object(r.b)(m.a,{value:"Unique Path II",mdxType:"TabItem"},Object(r.b)(u.default,{mdxType:"UniquePathsII"})),Object(r.b)(m.a,{value:"MinimumPathSum",mdxType:"TabItem"},Object(r.b)(c.default,{mdxType:"MinimumPathSum"})),Object(r.b)(m.a,{value:"MinimumFallingPathSum",mdxType:"TabItem"},Object(r.b)(s.default,{mdxType:"MinimumFallingPathSum"}))))}h.isMDXComponent=!0},131:function(e,n,t){"use strict";t.d(n,"a",(function(){return s})),t.d(n,"b",(function(){return b}));var i=t(0),a=t.n(i);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function m(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var u=a.a.createContext({}),c=function(e){var n=a.a.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):m(m({},n),e)),t},s=function(e){var n=c(e.components);return a.a.createElement(u.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},d=a.a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),s=c(t),d=i,b=s["".concat(o,".").concat(d)]||s[d]||p[d]||r;return t?a.a.createElement(b,m(m({ref:n},u),{},{components:t})):a.a.createElement(b,m({ref:n},u))}));function b(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=d;var m={};for(var l in n)hasOwnProperty.call(n,l)&&(m[l]=n[l]);m.originalType=e,m.mdxType="string"==typeof e?e:i,o[1]=m;for(var u=2;u<r;u++)o[u]=t[u];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},132:function(e,n,t){"use strict";function i(e){var n,t,a="";if("string"==typeof e||"number"==typeof e)a+=e;else if("object"==typeof e)if(Array.isArray(e))for(n=0;n<e.length;n++)e[n]&&(t=i(e[n]))&&(a&&(a+=" "),a+=t);else for(n in e)e[n]&&(a&&(a+=" "),a+=n);return a}n.a=function(){for(var e,n,t=0,a="";t<arguments.length;)(e=arguments[t++])&&(n=i(e))&&(a&&(a+=" "),a+=n);return a}},133:function(e,n,t){"use strict";var i=t(0),a=t.n(i),r=t(136),o=t(132),m=t(48),l=t.n(m);const u=37,c=39;n.a=function(e){const{block:n,children:t,defaultValue:m,values:s,groupId:p}=e,{tabGroupChoices:d,setTabGroupChoices:b}=Object(r.a)(),[g,h]=Object(i.useState)(m),[j,f]=Object(i.useState)(!1);if(null!=p){const e=d[p];null!=e&&e!==g&&s.some(n=>n.value===e)&&h(e)}const O=e=>{h(e),null!=p&&b(p,e)},P=[],y=e=>{e.metaKey||e.altKey||e.ctrlKey||f(!0)},v=()=>{f(!1)};return Object(i.useEffect)(()=>{window.addEventListener("keydown",y),window.addEventListener("mousedown",v)},[]),a.a.createElement("div",null,a.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(o.a)("tabs",{"tabs--block":n})},s.map(({value:e,label:n})=>a.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":g===e,className:Object(o.a)("tabs__item",l.a.tabItem,{"tabs__item--active":g===e}),style:j?{}:{outline:"none"},key:e,ref:e=>P.push(e),onKeyDown:e=>{((e,n,t)=>{switch(t.keyCode){case c:((e,n)=>{const t=e.indexOf(n)+1;e[t]?e[t].focus():e[0].focus()})(e,n);break;case u:((e,n)=>{const t=e.indexOf(n)-1;e[t]?e[t].focus():e[e.length-1].focus()})(e,n)}})(P,e.target,e),y(e)},onFocus:()=>O(e),onClick:()=>{O(e),f(!1)},onPointerDown:()=>f(!1)},n))),a.a.createElement("div",{role:"tabpanel",className:"margin-vert--md"},i.Children.toArray(t).filter(e=>e.props.value===g)[0]))}},134:function(e,n,t){"use strict";var i=t(0),a=t.n(i);n.a=function(e){return a.a.createElement("div",null,e.children)}},135:function(e,n,t){"use strict";var i=t(0);const a=Object(i.createContext)(void 0);n.a=a},136:function(e,n,t){"use strict";var i=t(0),a=t(135);n.a=function(){const e=Object(i.useContext)(a.a);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},148:function(e,n,t){"use strict";t.r(n),n.default=t.p+"assets/images/UnqiuePaths-e851675d74abe535a9b38e878b0ef1bc.jpg"},156:function(e,n,t){"use strict";t.r(n),n.default=t.p+"assets/images/MinimumPathSum-442c8c2cba704b5eb8e8baf1a7ec4672.jpg"},157:function(e,n,t){"use strict";t.r(n),n.default=t.p+"assets/images/UnqiuePathsII-1a74a9add9be3282543fdcf71d291ca8.jpg"},158:function(e,n,t){"use strict";t.r(n),n.default=t.p+"assets/images/MinimumFallingPathSum-a4ffea2f95fc4bf4f745c33c53b2cb67.jpg"},49:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return l})),t.d(n,"metadata",(function(){return u})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return p}));var i=t(1),a=t(6),r=(t(0),t(131)),o=t(133),m=t(134),l={title:"Leetcode 62. Unique Paths",tags:["DynamicProgramming/Coordinate"]},u={unversionedId:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/62-unique-paths",id:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/62-unique-paths",isDocsHomePage:!1,title:"Leetcode 62. Unique Paths",description:"Question Description",source:"@site/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/62-unique-paths.md",permalink:"/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/62-unique-paths"},c=[{value:"Example 1:",id:"example-1",children:[]},{value:"Example 2:",id:"example-2",children:[]}],s={rightToc:c};function p(e){var n=e.components,l=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(i.a)({},s,l,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,Object(r.b)("img",{src:t(148).default})),Object(r.b)("h1",{id:"question-description"},"Question Description"),Object(r.b)("p",null,"Original Question: ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://leetcode.com/problems/unique-paths/"}),"Leetcode 62. Unique Paths")),Object(r.b)("p",null,"A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below)."),Object(r.b)("p",null,"The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below)."),Object(r.b)("p",null,"How many possible unique paths are there?"),Object(r.b)("h3",{id:"example-1"},"Example 1:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{}),"Input: m = 3, n = 2\nOutput: 3\nExplanation:\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Right -> Down\n2. Right -> Down -> Right\n3. Down -> Right -> Right\n")),Object(r.b)("h3",{id:"example-2"},"Example 2:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{}),"Input: m = 7, n = 3\nOutput: 28\n")),Object(r.b)("h1",{id:"solution"},"Solution"),Object(r.b)(o.a,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Python",value:"py"}],mdxType:"Tabs"},Object(r.b)(m.a,{value:"java",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"class Solution {\n    public int uniquePaths(int m, int n) {\n        if(m == 0|| n==0) return 0;\n        int[][] dp = new int[m][n];\n        for(int i = 0; i < m; i++){\n            dp[i][n-1] = 1;\n        }\n        for(int i = 0; i < n; i++){\n            dp[m-1][i] = 1;\n        }\n        for(int j = m-2; j>=0; j--){\n            for(int i = n-2; i>=0;i--){\n                dp[j][i] = dp[j+1][i] + dp[j][i+1];\n            }\n        }\n        return dp[0][0];\n    }\n}\n"))),Object(r.b)(m.a,{value:"py",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-py"}),"class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        if not m or not n:\n            return 0\n\n        paths = [[1]*(n+1)]*(m +1)\n\n        for i in range(2,m+1):\n            for j in range(2, n+1):\n                paths[i][j] = paths[i-1][j] + paths[i][j-1]\n\n        return paths[m][n]\n")))))}p.isMDXComponent=!0},52:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return l})),t.d(n,"metadata",(function(){return u})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return p}));var i=t(1),a=t(6),r=(t(0),t(131)),o=t(133),m=t(134),l={title:"Leetcode 64. Minimum Path Sum",tags:["DynamicProgramming/Coordinate"]},u={unversionedId:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/64-minimum-path-sum",id:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/64-minimum-path-sum",isDocsHomePage:!1,title:"Leetcode 64. Minimum Path Sum",description:"Question Description",source:"@site/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/64-minimum-path-sum.md",permalink:"/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/64-minimum-path-sum"},c=[{value:"Example:",id:"example",children:[]}],s={rightToc:c};function p(e){var n=e.components,l=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(i.a)({},s,l,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,Object(r.b)("img",{src:t(156).default})),Object(r.b)("h1",{id:"question-description"},"Question Description"),Object(r.b)("p",null,"Original Question: ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://leetcode.com/problems/minimum-path-sum/"}),"Leetcode 64. Minimum Path Sum")),Object(r.b)("p",null,"Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path."),Object(r.b)("p",null,"Note: You can only move either down or right at any point in time."),Object(r.b)("h3",{id:"example"},"Example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-aidl"}),"Input:\n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\nOutput: 7\nExplanation: Because the path 1\u21923\u21921\u21921\u21921 minimizes the sum.\n")),Object(r.b)("h1",{id:"solution"},"Solution"),Object(r.b)(o.a,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Python",value:"py"}],mdxType:"Tabs"},Object(r.b)(m.a,{value:"java",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"class Solution {\n    public int minPathSum(int[][] grid) {\n        if(grid.length == 0 || grid[0].length == 0) return 0;\n        int[][] dp = new int [grid.length][grid[0].length];\n        for(int i = 0; i<grid.length; i++){\n            for(int j = 0; j < grid[0].length; j++){\n                if(i==0 && j==0) dp[i][j] = grid[0][0];\n                else if(i==0) {\n                    dp[i][j] = grid[i][j] + dp[i][j-1];\n                } else if (j == 0){\n                    dp[i][j] = grid[i][j] + dp[i-1][j];\n                } else {\n                    dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);\n                }\n            }\n        }\n        return dp[grid.length-1][grid[0].length-1];\n    }\n}\n"))),Object(r.b)(m.a,{value:"py",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-py"}),"class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n\n        m,n = len(grid), len(grid[0])\n\n\n        minSum = [[0 for j in range(n)] for i in range(m) ] \n        minSum[0][0] = grid[0][0]\n\n        for i in range(1,m):\n            minSum[i][0] = minSum[i-1][0] + grid[i][0]\n\n        for j in range(1,n):\n            minSum[0][j] = minSum[0][j-1] + grid[0][j]\n\n        for i in range(1,m):\n            for j in range(1,n):\n                minSum[i][j] = min(minSum[i-1][j], minSum[i][j-1]) + grid[i][j]\n\n        return minSum[m-1][n-1]\n")))))}p.isMDXComponent=!0},54:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return l})),t.d(n,"metadata",(function(){return u})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return p}));var i=t(1),a=t(6),r=(t(0),t(131)),o=t(133),m=t(134),l={title:"Leetcode 63. Unique Paths II",tags:["DynamicProgramming/Coordinate"]},u={unversionedId:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/63-unique-paths-ii",id:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/63-unique-paths-ii",isDocsHomePage:!1,title:"Leetcode 63. Unique Paths II",description:"Question Description",source:"@site/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/63-unique-paths-ii.md",permalink:"/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/63-unique-paths-ii"},c=[{value:"Example:",id:"example",children:[]}],s={rightToc:c};function p(e){var n=e.components,l=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(i.a)({},s,l,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,Object(r.b)("img",{src:t(157).default})),Object(r.b)("h1",{id:"question-description"},"Question Description"),Object(r.b)("p",null,"Original Question: ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://leetcode.com/problems/unique-paths-ii/"}),"Leetcode 63. Unique Paths II")),Object(r.b)("p",null,"A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below)."),Object(r.b)("p",null,"The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below)."),Object(r.b)("p",null,"Now consider if some obstacles are added to the grids. How many unique paths would there be?"),Object(r.b)("h3",{id:"example"},"Example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-aidl"}),"Input:\n[\n  [0,0,0],\n  [0,1,0],\n  [0,0,0]\n]\nOutput: 2\nExplanation:\nThere is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n")),Object(r.b)("h1",{id:"solution"},"Solution"),Object(r.b)(o.a,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Python",value:"py"}],mdxType:"Tabs"},Object(r.b)(m.a,{value:"java",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"class Solution {\n    public int uniquePaths(int m, int n) {\n        if(m == 0|| n==0) return 0;\n        int[][] dp = new int[m][n];\n        for(int i = 0; i < m; i++){\n            dp[i][n-1] = 1;\n        }\n        for(int i = 0; i < n; i++){\n            dp[m-1][i] = 1;\n        }\n        for(int j = m-2; j>=0; j--){\n            for(int i = n-2; i>=0;i--){\n                dp[j][i] = dp[j+1][i] + dp[j][i+1];\n            }\n        }\n        return dp[0][0];\n    }\n}\n"))),Object(r.b)(m.a,{value:"py",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-py"}),"class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        if not m or not n:\n            return 0\n\n        paths = [[1]*(n+1)]*(m +1)\n\n        for i in range(2,m+1):\n            for j in range(2, n+1):\n                paths[i][j] = paths[i-1][j] + paths[i][j-1]\n\n        return paths[m][n]\n")))))}p.isMDXComponent=!0},55:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return l})),t.d(n,"metadata",(function(){return u})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return p}));var i=t(1),a=t(6),r=(t(0),t(131)),o=t(133),m=t(134),l={title:"Leetcode 931. Minimum Falling Path Sum",tags:["DynamicProgramming/Coordinate"]},u={unversionedId:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/931-minimum-falling-path-sum",id:"Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/931-minimum-falling-path-sum",isDocsHomePage:!1,title:"Leetcode 931. Minimum Falling Path Sum",description:"Question Description",source:"@site/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/931-minimum-falling-path-sum.md",permalink:"/docs/Patterns/DynamicProgramming/Coordinate/OptimalPathFinding/931-minimum-falling-path-sum"},c=[{value:"Example:",id:"example",children:[]}],s={rightToc:c};function p(e){var n=e.components,l=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(i.a)({},s,l,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,Object(r.b)("img",{src:t(158).default})),Object(r.b)("h1",{id:"question-description"},"Question Description"),Object(r.b)("p",null,"Original Question: ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://leetcode.com/problems/minimum-falling-path-sum/"}),"931. Minimum Falling Path Sum")),Object(r.b)("p",null,"Given a square array of integers A, we want the minimum sum of a falling path through A."),Object(r.b)("p",null,"A falling path starts at any element in the first row, and chooses one element from each row.  The next row's choice must be in a column that is different from the previous row's column by at most one."),Object(r.b)("h3",{id:"example"},"Example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-aidl"}),"Input: [[1,2,3],[4,5,6],[7,8,9]]\nOutput: 12\nExplanation: \nThe possible falling paths are:\n- [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]\n- [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]\n- [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]\n\nThe falling path with the smallest sum is [1,4,7], so the answer is 12.\n\n")),Object(r.b)("h1",{id:"solution"},"Solution"),Object(r.b)(o.a,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Python",value:"py"}],mdxType:"Tabs"},Object(r.b)(m.a,{value:"java",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"class Solution {\n    public int minFallingPathSum(int[][] A) {\n        int m = A.length, n = A[0].length;\n        int[][] dp = new int[m][n];\n        for(int i = 0; i < n; i++){\n            dp[0][i] = A[0][i];\n        }\n        for(int i = 1; i < m; i++){\n            for(int j = 0; j < n; j++){\n                int topLeft = j-1 < 0 ? Integer.MAX_VALUE : dp[i-1][j-1];\n                int topMid = dp[i-1][j];\n                int topRight = j+1 >= n ? Integer.MAX_VALUE : dp[i-1][j+1];\n                dp[i][j] = A[i][j] + Math.min(topLeft, Math.min(topMid, topRight));\n            }\n        }\n        int smallestPath = Integer.MAX_VALUE;\n        for(int i = 0; i < n; i++){\n            smallestPath = Math.min(smallestPath, dp[m-1][i]);\n        }\n        return smallestPath;\n    }\n}\n"))),Object(r.b)(m.a,{value:"py",mdxType:"TabItem"},Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-py"}),"class Solution:\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\n        for i in range(1,len(A)):\n            for j in range(len(A[0])):\n                if j == 0:\n                    A[i][j]  = min((A[i][j] + A[i - 1][j]), (A[i][j] + A[i - 1][j + 1]) )\n                elif (j == len(A[0]) - 1):\n                    A[i][j]  = min((A[i][j] + A[i - 1][j]), (A[i][j] + A[i - 1][j - 1]) )\n                else:\n                    A[i][j] = min(A[i][j] + A[i - 1][j],A[i][j] + A[i - 1][j + 1], A[i][j] + A[i - 1][j - 1])\n            \n        return min(A[len(A) - 1])\n")))))}p.isMDXComponent=!0}}]);