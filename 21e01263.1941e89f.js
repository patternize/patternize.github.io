(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{149:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return f}));var r=n(0),a=n.n(r);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=a.a.createContext({}),u=function(e){var t=a.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=u(e.components);return a.a.createElement(s.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},h=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),d=u(n),h=r,f=d["".concat(l,".").concat(h)]||d[h]||b[h]||o;return n?a.a.createElement(f,i(i({ref:t},s),{},{components:n})):a.a.createElement(f,i({ref:t},s))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=h;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,l[1]=i;for(var s=2;s<o;s++)l[s]=n[s];return a.a.createElement.apply(null,l)}return a.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},150:function(e,t,n){"use strict";function r(e){var t,n,a="";if("string"==typeof e||"number"==typeof e)a+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=r(e[t]))&&(a&&(a+=" "),a+=n);else for(t in e)e[t]&&(a&&(a+=" "),a+=t);return a}t.a=function(){for(var e,t,n=0,a="";n<arguments.length;)(e=arguments[n++])&&(t=r(e))&&(a&&(a+=" "),a+=t);return a}},151:function(e,t,n){"use strict";var r=n(0),a=n.n(r),o=n(153),l=n(150),i=n(55),c=n.n(i);const s=37,u=39;t.a=function(e){const{lazy:t,block:n,defaultValue:i,values:d,groupId:b,className:h}=e,{tabGroupChoices:f,setTabGroupChoices:m}=Object(o.a)(),[p,v]=Object(r.useState)(i),y=r.Children.toArray(e.children);if(null!=b){const e=f[b];null!=e&&e!==p&&d.some((t=>t.value===e))&&v(e)}const O=e=>{v(e),null!=b&&m(b,e)},g=[];return a.a.createElement("div",null,a.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(l.a)("tabs",{"tabs--block":n},h)},d.map((({value:e,label:t})=>a.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":p===e,className:Object(l.a)("tabs__item",c.a.tabItem,{"tabs__item--active":p===e}),key:e,ref:e=>g.push(e),onKeyDown:e=>{((e,t,n)=>{switch(n.keyCode){case u:((e,t)=>{const n=e.indexOf(t)+1;e[n]?e[n].focus():e[0].focus()})(e,t);break;case s:((e,t)=>{const n=e.indexOf(t)-1;e[n]?e[n].focus():e[e.length-1].focus()})(e,t)}})(g,e.target,e)},onFocus:()=>O(e),onClick:()=>{O(e)}},t)))),t?Object(r.cloneElement)(y.filter((e=>e.props.value===p))[0],{className:"margin-vert--md"}):a.a.createElement("div",{className:"margin-vert--md"},y.map(((e,t)=>Object(r.cloneElement)(e,{key:t,hidden:e.props.value!==p})))))}},152:function(e,t,n){"use strict";var r=n(3),a=n(0),o=n.n(a);t.a=function({children:e,hidden:t,className:n}){return o.a.createElement("div",Object(r.a)({role:"tabpanel"},{hidden:t,className:n}),e)}},153:function(e,t,n){"use strict";var r=n(0),a=n(154);t.a=function(){const e=Object(r.useContext)(a.a);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},154:function(e,t,n){"use strict";var r=n(0);const a=Object(r.createContext)(void 0);t.a=a},87:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return u})),n.d(t,"default",(function(){return b}));var r=n(3),a=n(7),o=(n(0),n(149)),l=n(151),i=n(152),c={id:"LC98",title:"LC98. Validate Binary Search Tree",sidebar_label:"LC98. Validate Binary Search Tree",tags:["Patterns/Tree","DataStructures/Tree"]},s={unversionedId:"QuestionBank/Leetcode/LC98",id:"QuestionBank/Leetcode/LC98",isDocsHomePage:!1,title:"LC98. Validate Binary Search Tree",description:"Problem Description",source:"@site/docs/QuestionBank/Leetcode/98. Validate Binary Search Tree.md",slug:"/QuestionBank/Leetcode/LC98",permalink:"/docs/QuestionBank/Leetcode/LC98",version:"current",sidebar_label:"LC98. Validate Binary Search Tree",sidebar:"Data Structure",previous:{title:"Traversals",permalink:"/docs/DataStructures/Basic/BinaryTree/BSTTraversals"},next:{title:"LC101. Symmetric Tree",permalink:"/docs/QuestionBank/Leetcode/LC101"}},u=[{value:"Problem Description",id:"problem-description",children:[]},{value:"Solution",id:"solution",children:[{value:"High level strategy",id:"high-level-strategy",children:[]},{value:"Code",id:"code",children:[]}]}],d={toc:u};function b(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},d,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"problem-description"},"Problem Description"),Object(o.b)("p",null,"Source: ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://leetcode.com/problems/validate-binary-search-tree/"}),"https://leetcode.com/problems/validate-binary-search-tree/")),Object(o.b)("p",null,"Given the root of a binary tree, determine if it is a valid binary search tree (BST)."),Object(o.b)("p",null,"A ",Object(o.b)("strong",{parentName:"p"},"valid BST")," is defined as follows:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"The left subtree of a node contains only nodes with keys ",Object(o.b)("strong",{parentName:"li"},"less than")," the node's key."),Object(o.b)("li",{parentName:"ul"},"The right subtree of a node contains only nodes with keys ",Object(o.b)("strong",{parentName:"li"},"greater than")," the node's key."),Object(o.b)("li",{parentName:"ul"},"Both the left and right subtrees must also be binary search trees.")),Object(o.b)("p",null,"For example: Given binary tree ","[5, 1, 12, null, null, 15, 16]",","),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),"    5\n   / \\\n  1  12\n    /  \\\n   15   16\n")),Object(o.b)("p",null,"return false, since 15 is the left child of 12, but is greater than 12. "),Object(o.b)("h2",{id:"solution"},"Solution"),Object(o.b)("h3",{id:"high-level-strategy"},"High level strategy"),Object(o.b)("p",null,"To check whether a tree is a valid binary search tree, we must compare the value of the current node with the values of its parent or grandparent node. If the current node is the left child of its parent node, then its value cannot be greater than its parent. If the current node is the right child of its parent node, then its value cannot be lesser than its parent. Therefore, as we traverse down the binary search tree, we must pass the value of the current node as the minimum value or the maximum value against which the values of its children will be compared. "),Object(o.b)("p",null,"To implement our strategy, we will initialize the minimum value and the maximum value with null. We will keep the initial minimum value and pass the value of the current node as the maxmimum value as we recurse down the left side of the current node. We will keep the initial maximum value and pass the value of the current node as the minimum value as we recurse down the right side of the current node. We will return false if the minimum value is greater or equal to the value of the current node, and return false if the maximum value is lesser or equal to the value of the current node. We will only return true if we have reached the leaf of a tree, by which point the binary search tree invariant has yet to be violated. As we recurse back to the bottom-most level of the call stack, we expect both sides of the tree to return true, and we will only return true if and only if both sides return true. The time complexity of this solution is ",Object(o.b)("strong",{parentName:"p"},"O(n)"),", where 'n' is equal to the number of nodes. The space complexity of this solution is ",Object(o.b)("strong",{parentName:"p"},"O(h)"),", where h is equal to the height of the tree, which is equal to the log of 'n' on average, where 'n' is equal to the number of nodes. Therefore, the space complexity of this solution can also be expressed in the form of ",Object(o.b)("strong",{parentName:"p"},"O(logn)"),"."),Object(o.b)("h3",{id:"code"},"Code"),Object(o.b)(l.a,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Javascript",value:"js"},{label:"Python",value:"py"}],mdxType:"Tabs"},Object(o.b)(i.a,{value:"java",mdxType:"TabItem"},Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public boolean isValidBST(TreeNode root) {\n        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n    \n    public boolean isValidBST(TreeNode root, long minVal, long maxVal) {\n        if (root == null) return true;\n        if (root.val >= maxVal || root.val <= minVal) return false;\n        return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);\n    }\n}\n"))),Object(o.b)(i.a,{value:"js",mdxType:"TabItem"},Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-javascript"}),"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n **/\n\nconst isValidBST = (root) => {\n    return helper(root, null, null);\n};\n\nconst helper = (node, min, max) => {\n    if (node === null) return true;\n    if (min !== null && min >= node.val) return false;\n    if (max !== null && max <= node.val) return false;\n    \n    return helper(node.left, min, node.val) && helper(node.right, node.val, max);\n};\n"))),Object(o.b)(i.a,{value:"py",mdxType:"TabItem"},Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def isValidBST(self, root: TreeNode) -> bool:        \n    def validate(node, min_, max_):\n        if not node:\n            return True \n        if not (min_ < node.val < max_):\n            return False \n        return validate(node.left, min_, node.val) and validate(node.right, node.val, max_)\n    return validate(root,float('-inf'), float('inf'))\n")))))}b.isMDXComponent=!0}}]);